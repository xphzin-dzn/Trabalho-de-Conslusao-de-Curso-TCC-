{"version":3,"file":"ts-async.js","sources":["https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/internal/constants.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/promise/await.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/internal/treeshake_helpers.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/promise/debug.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/internal/state.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/promise/event.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/promise/base.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/promise/itemProcessor.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/promise/asyncPromise.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/promise/nativePromise.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/promise/syncPromise.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/promise/idlePromise.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/promise/promise.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/promise/timeoutPromise.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/helpers/doWhileAsync.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/helpers/arrForEachAsync.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/helpers/iterForOfAsync.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/scheduler/taskScheduler.ts","https://raw.githubusercontent.com/nevware21/ts-async/refs/tags/0.5.4/lib/src/polyfills/promise.ts"],"sourcesContent":["/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2023 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nexport const STR_PROMISE = \"Promise\";\r\nexport const DONE = \"done\";\r\nexport const VALUE = \"value\";\r\nexport const ITERATOR = \"iterator\";\r\nexport const RETURN = \"return\";\r\nexport const REJECTED = \"rejected\";","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { isPromiseLike } from \"@nevware21/ts-utils\";\r\nimport { AwaitResponse } from \"../interfaces/await-response\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { FinallyPromiseHandler, RejectedPromiseHandler, ResolvedPromiseHandler } from \"../interfaces/types\";\r\nimport { REJECTED } from \"../internal/constants\";\r\n\r\n/**\r\n * Helper to coallesce the promise resolved / reject into a single callback to simplify error handling.\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait\r\n * @param cb - The callback function to call with the resulting value, if the value is not a\r\n * promise like value then the callback is called synchronously, if the value is a promise then\r\n * the callback will be called once the promise completes the resulting value will be passed as an\r\n * IAwaitResponse instance, it will be called whether any promise resolves or rejects.\r\n * @returns The value returned by the `cb` callback function, if the value is a promise then the return value\r\n * of the callback will be returned as a promise whether the callback returns a promise or not.\r\n * @example\r\n * ```ts\r\n * let promise = createPromise<number>((resolve, reject) => {\r\n *     resolve(42);\r\n * });\r\n *\r\n * // Handle via doAwaitResponse\r\n * doAwaitResponse(promise, (value) => {\r\n *     if (!value.rejected) {\r\n *          // Do something with the value\r\n *     } else {\r\n *         // Do something with the reason\r\n *     }\r\n * });\r\n *\r\n * // It can also handle the raw value, so you could process the result of either a\r\n * // synchrounous return of the value or a Promise\r\n * doAwaitResponse(42, (value) => {\r\n *     if (!value.rejected) {\r\n *         // Do something with the value\r\n *     } else {\r\n *        // This will never be true as the value is not a promise\r\n *     }\r\n * });\r\n * ```\r\n */\r\nexport function doAwaitResponse<T, TResult1 = T, TResult2 = never>(value: T | Promise<T>, cb: (response: AwaitResponse<T | TResult1>) => T | TResult1 | TResult2 | Promise<T | TResult1 | TResult2>): T | TResult1 | TResult2 | Promise<T | TResult1 | TResult2>;\r\n\r\n/**\r\n * Helper to coallesce the promise resolved / reject into a single callback to simplify error handling.\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param cb - The callback function to call with the resulting value, if the value is not a\r\n * promise like value then the callback is called synchronously, if the value is a promise then\r\n * the callback will be called once the promise completes the resulting value will be passed as an\r\n * IAwaitResponse instance, it will be called whether any promise resolves or rejects.\r\n * @returns The value returned by the `cb` callback function, if the value is a promise then the return value\r\n * of the callback will be returned as a promise whether the callback returns a promise or not.\r\n * @example\r\n * ```ts\r\n * let promise = createPromise<number>((resolve, reject) => {\r\n *     resolve(42);\r\n * });\r\n *\r\n * // Handle via doAwaitResponse\r\n * doAwaitResponse(promise, (value) => {\r\n *     if (!value.rejected) {\r\n *          // Do something with the value\r\n *     } else {\r\n *         // Do something with the reason\r\n *     }\r\n * });\r\n *\r\n * // It can also handle the raw value, so you could process the result of either a\r\n * // synchrounous return of the value or a Promise\r\n * doAwaitResponse(42, (value) => {\r\n *     if (!value.rejected) {\r\n *         // Do something with the value\r\n *     } else {\r\n *        // This will never be true as the value is not a promise\r\n *     }\r\n * });\r\n * ```\r\n */\r\nexport function doAwaitResponse<T, TResult1 = T, TResult2 = never>(value: T | PromiseLike<T>, cb: (response: AwaitResponse<T | TResult1>) => T | TResult1 | TResult2 | PromiseLike<T | TResult1 | TResult2>): T | TResult1 | TResult2 | PromiseLike<T | TResult1 | TResult2>;\r\n\r\n/**\r\n * Helper to coallesce the promise resolved / reject into a single callback to simplify error handling.\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait to be resolved or rejected.\r\n * @param cb - The callback function to call with the resulting value, if the value is not a\r\n * promise like value then the callback is called synchronously, if the value is a promise then\r\n * the callback will be called once the promise completes the resulting value will be passed as an\r\n * IAwaitResponse instance, it will be called whether any promise resolves or rejects.\r\n * @returns The value returned by the `cb` callback function, if the value is a promise then the return value\r\n * of the callback will be returned as a promise whether the callback returns a promise or not.\r\n * @example\r\n * ```ts\r\n * let promise = createPromise<number>((resolve, reject) => {\r\n *     resolve(42);\r\n * });\r\n *\r\n * // Handle via doAwaitResponse\r\n * doAwaitResponse(promise, (value) => {\r\n *     if (!value.rejected) {\r\n *          // Do something with the value\r\n *     } else {\r\n *         // Do something with the reason\r\n *     }\r\n * });\r\n *\r\n * // It can also handle the raw value, so you could process the result of either a\r\n * // synchrounous return of the value or a Promise\r\n * doAwaitResponse(42, (value) => {\r\n *     if (!value.rejected) {\r\n *         // Do something with the value\r\n *     } else {\r\n *        // This will never be true as the value is not a promise\r\n *     }\r\n * });\r\n * ```\r\n */\r\nexport function doAwaitResponse<T, TResult1 = T, TResult2 = never>(value: T | IPromise<T>, cb: (response: AwaitResponse<T | TResult1>) => T | TResult1 | TResult2 | IPromise<T | TResult1 | TResult2>): T | TResult1 | TResult2 | IPromise<T | TResult1 | TResult2> {\r\n    return doAwait(value as T, (value) => {\r\n        return cb ? cb({\r\n            status: \"fulfilled\",\r\n            rejected: false,\r\n            value: value\r\n        }) : value;\r\n    },\r\n    (reason) => {\r\n        return cb ? cb({\r\n            status: REJECTED,\r\n            rejected: true,\r\n            reason: reason\r\n        }) : reason;\r\n    });\r\n}\r\n\r\n/**\r\n * Wait for the promise to resolve or reject, if resolved the callback function will be called with it's value and if\r\n * rejected the rejectFn will be called with the reason. If the passed promise argument is not a promise the callback\r\n * will be called synchronously with the value.\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param resolveFn - The callback to call on the promise successful resolving.\r\n * @param rejectFn - The callback to call when the promise rejects\r\n * @param finallyFn - The callback to call once the promise has resolved or rejected\r\n * @returns The passed value, if it is a promise and there is either a resolve or reject handler\r\n * then it will return a chained promise with the value from the resolve or reject handler (depending\r\n * whether it resolve or rejects)\r\n * @example\r\n * ```ts\r\n * let promise = createPromise<number>((resolve, reject) => {\r\n *     resolve(42);\r\n * });\r\n *\r\n * // Handle via a chained promise\r\n * let chainedPromise = promise.then((value) => {\r\n *     // Do something with the value\r\n * });\r\n *\r\n * // Handle via doAwait\r\n * doAwait(promise, (value) => {\r\n *     // Do something with the value\r\n * });\r\n *\r\n * // It can also handle the raw value, so you could process the result of either a\r\n * // synchrounous return of the value or a Promise\r\n * doAwait(42, (value) => {\r\n *     // Do something with the value\r\n * });\r\n * ```\r\n */\r\nexport function doAwait<T, TResult1 = T, TResult2 = never>(value: T | Promise<T>, resolveFn: ResolvedPromiseHandler<T, TResult1>, rejectFn?: RejectedPromiseHandler<TResult2>, finallyFn?: FinallyPromiseHandler): TResult1 | TResult2 | Promise<TResult1 | TResult2>;\r\n\r\n/**\r\n * Wait for the promise to resolve or reject, if resolved the callback function will be called with it's value and if\r\n * rejected the rejectFn will be called with the reason. If the passed promise argument is not a promise the callback\r\n * will be called synchronously with the value.\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param resolveFn - The callback to call on the promise successful resolving.\r\n * @param rejectFn - The callback to call when the promise rejects\r\n * @param finallyFn - The callback to call once the promise has resolved or rejected\r\n * @returns The passed value, if it is a promise and there is either a resolve or reject handler\r\n * then it will return a chained promise with the value from the resolve or reject handler (depending\r\n * whether it resolve or rejects)\r\n * @example\r\n * ```ts\r\n * let promise = createPromise<number>((resolve, reject) => {\r\n *     resolve(42);\r\n * });\r\n *\r\n * // Handle via a chained promise\r\n * let chainedPromise = promise.then((value) => {\r\n *     // Do something with the value\r\n * });\r\n *\r\n * // Handle via doAwait\r\n * doAwait(promise, (value) => {\r\n *     // Do something with the value\r\n * });\r\n *\r\n * // It can also handle the raw value, so you could process the result of either a\r\n * // synchrounous return of the value or a Promise\r\n * doAwait(42, (value) => {\r\n *     // Do something with the value\r\n * });\r\n * ```\r\n */\r\nexport function doAwait<T, TResult1 = T, TResult2 = never>(value: T | PromiseLike<T>, resolveFn: ResolvedPromiseHandler<T, TResult1>, rejectFn?: RejectedPromiseHandler<TResult2>, finallyFn?: FinallyPromiseHandler): TResult1 | TResult2 | PromiseLike<TResult1 | TResult2>;\r\n\r\n/**\r\n * Wait for the promise to resolve or reject, if resolved the callback function will be called with it's value and if\r\n * rejected the rejectFn will be called with the reason. If the passed promise argument is not a promise the callback\r\n * will be called synchronously with the value.\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param resolveFn - The callback to call on the promise successful resolving.\r\n * @param rejectFn - The callback to call when the promise rejects\r\n * @param finallyFn - The callback to call once the promise has resolved or rejected\r\n * @returns The passed value, if it is a promise and there is either a resolve or reject handler\r\n * then it will return a chained promise with the value from the resolve or reject handler (depending\r\n * whether it resolve or rejects)\r\n * @example\r\n * ```ts\r\n * let promise = createPromise<number>((resolve, reject) => {\r\n *     resolve(42);\r\n * });\r\n *\r\n * // Handle via a chained promise\r\n * let chainedPromise = promise.then((value) => {\r\n *     // Do something with the value\r\n * });\r\n *\r\n * // Handle via doAwait\r\n * doAwait(promise, (value) => {\r\n *     // Do something with the value\r\n * });\r\n *\r\n * // It can also handle the raw value, so you could process the result of either a\r\n * // synchrounous return of the value or a Promise\r\n * doAwait(42, (value) => {\r\n *     // Do something with the value\r\n * });\r\n * ```\r\n */\r\nexport function doAwait<T, TResult1 = T, TResult2 = never>(value: T | IPromise<T>, resolveFn: ResolvedPromiseHandler<T, TResult1>, rejectFn?: RejectedPromiseHandler<TResult2>, finallyFn?: FinallyPromiseHandler): TResult1 | TResult2 | IPromise<TResult1 | TResult2> {\r\n    let result: T | TResult1 | TResult2 | IPromise<T | TResult1 | TResult2> | PromiseLike<TResult1 | TResult2> = value;\r\n    \r\n    try {\r\n        if (isPromiseLike<T>(value)) {\r\n            if (resolveFn || rejectFn) {\r\n                result = value.then(resolveFn, rejectFn) as any;\r\n            }\r\n        } else {\r\n            try {\r\n                if (resolveFn) {\r\n                    result = resolveFn(value);\r\n                }\r\n            } catch (err) {\r\n                if (rejectFn) {\r\n                    result = rejectFn(err);\r\n                } else {\r\n                    throw err;\r\n                }\r\n            }\r\n        }\r\n    } finally {\r\n        if (finallyFn) {\r\n            doFinally(result as any, finallyFn);\r\n        }\r\n    }\r\n\r\n    return result as any;\r\n}\r\n\r\n/**\r\n * Wait for the promise to resolve or reject and then call the finallyFn. If the passed promise argument is not a promise the callback\r\n * will be called synchronously with the value. If the passed promise doesn't implement finally then a finally implementation will be\r\n * simulated using then(..., ...).\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param finallyFn - The finally function to call once the promise has resolved or rejected\r\n */\r\nexport function doFinally<T>(value: T | Promise<T>, finallyFn: FinallyPromiseHandler): T | Promise<T>;\r\n\r\n/**\r\n * Wait for the promise to resolve or reject and then call the finallyFn. If the passed promise argument is not a promise the callback\r\n * will be called synchronously with the value. If the passed promise doesn't implement finally then a finally implementation will be\r\n * simulated using then(..., ...).\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param finallyFn - The finally function to call once the promise has resolved or rejected\r\n */\r\nexport function doFinally<T>(value: T | PromiseLike<T>, finallyFn: FinallyPromiseHandler): T | PromiseLike<T>;\r\n\r\n/**\r\n * Wait for the promise to resolve or reject and then call the finallyFn. If the passed promise argument is not a promise the callback\r\n * will be called synchronously with the value. If the passed promise doesn't implement finally then a finally implementation will be\r\n * simulated using then(..., ...).\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param finallyFn - The finally function to call once the promise has resolved or rejected\r\n */\r\nexport function doFinally<T>(value: T | IPromise<T>, finallyFn: FinallyPromiseHandler): T | IPromise<T> {\r\n    let result = value;\r\n    if (finallyFn) {\r\n        if (isPromiseLike<T>(value)) {\r\n            if ((value as IPromise<T>).finally) {\r\n                result = (value as IPromise<T>).finally(finallyFn);\r\n            } else {\r\n                // Simulate finally if not available\r\n                result = value.then(\r\n                    function(value) {\r\n                        finallyFn();\r\n                        return value;\r\n                    }, function(reason: any) {\r\n                        finallyFn();\r\n                        throw reason;\r\n                    });\r\n            }\r\n        } else {\r\n            finallyFn();\r\n        }\r\n    }\r\n\r\n    return result;\r\n}","/*\r\n * @nevware21/ts-utils\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2024 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal tree shaking helper to return the first available function from the two provided.\r\n * This is required to ensure that tree-shaking can remove any unused functions as this ensures\r\n * that the alias assignments are not considered side-effects and are tagged correctly as pure.\r\n * @param func1 - The system function to use if available\r\n * @param func2 - The polyfill function to use if the static function is not available\r\n * @returns The first available function from the two provided\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _pureAssign<F>(func1: F, func2?: F): F {\r\n    return func1 || func2;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal tree shaking helper to return the value of the named property from the provided object.\r\n * By using this helper, we can explicitly tell the tree-shaking tools that this function is pure and\r\n * has no side effects. As some tree-shaking tools may not be able to determine this automatically.\r\n * @param value - The object to get the property value from\r\n * @param name - The name of the property to get the value of\r\n * @returns The value of the named property from the provided object\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _pureRef<R extends T[keyof T], T = any>(value: T, name: keyof T): R {\r\n    return value[name] as R;\r\n}","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { objDefineProperties } from \"@nevware21/ts-utils\";\r\nimport { _pureAssign } from \"../internal/treeshake_helpers\";\r\n\r\nlet _debugState: any;\r\nlet _debugResult: any;\r\nlet _debugHandled: any;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n */\r\nexport let _promiseDebugEnabled = false;\r\n\r\n//#ifdef DEBUG\r\n//#:(!DEBUG) let _theLogger: (id: string, message: string) => void = null;\r\n//#endif\r\n\r\n/**\r\n * @internal\r\n * @ignore Internal function enable logging the internal state of the promise during execution, this code and references are\r\n * removed from the production artifacts\r\n */\r\nexport const _debugLog = (/*#__PURE__*/_pureAssign((id: string, message: string) => {\r\n    //#ifdef DEBUG\r\n    //#:(!DEBUG) if (_theLogger) {\r\n    //#:(!DEBUG)     _theLogger(id, message);\r\n    //#:(!DEBUG) }\r\n    //#endif\r\n}));\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal function to add the debug state to the promise so that it provides simular visibility as you would\r\n * see from native promises\r\n * @param thePromise - The Promise implementation\r\n * @param stateFn - The function to return the state of the promise\r\n * @param resultFn - The function to return the result (settled value) of the promise\r\n * @param handledFn - The function to return whether the promise has been handled (used for throwing\r\n * unhandled rejection events)\r\n */\r\nexport function _addDebugState(thePromise: any, stateFn: () => string, resultFn: () => string, handledFn: () => boolean) {\r\n    // While the IPromise implementations provide a `state` property, keeping the `[[PromiseState]]`\r\n    // as native promises also have a non-enumerable property of the same name\r\n    _debugState = _debugState || { toString: () => \"[[PromiseState]]\" };\r\n    _debugResult = _debugResult || { toString: () => \"[[PromiseResult]]\" };\r\n    _debugHandled = _debugHandled || { toString: () => \"[[PromiseIsHandled]]\" };\r\n    \r\n    let props: PropertyDescriptorMap = {};\r\n    props[_debugState] = { get: stateFn };\r\n    props[_debugResult] = { get: resultFn };\r\n    props[_debugHandled] = { get: handledFn };\r\n\r\n    objDefineProperties(thePromise, props);\r\n}\r\n\r\n/**\r\n * Debug helper to enable internal debugging of the promise implementations. Disabled by default.\r\n * For the generated packages included in the npm package the `logger` will not be called as the\r\n * `_debugLog` function that uses this logger is removed during packaging.\r\n *\r\n * It is available directly from the repository for unit testing.\r\n *\r\n * @group Debug\r\n * @param enabled - Should debugging be enabled (defaults `false`, when `true` promises will have\r\n * additional debug properties and the `toString` will include extra details.\r\n * @param logger - Optional logger that will log internal state changes, only called in debug\r\n * builds as the calling function is removed is the production artifacts.\r\n * @example\r\n * ```ts\r\n * // The Id is the id of the promise\r\n * // The message is the internal debug message\r\n * function promiseDebugLogger(id: string, message: string) {\r\n *     if (console && console.log) {\r\n *         console.log(id, message);\r\n *     }\r\n * }\r\n *\r\n * setPromiseDebugState(true, promiseDebugLogger);\r\n *\r\n * // While the logger will not be called for the production packages\r\n * // Setting the `enabled` flag to tru will cause each promise to have\r\n * // the following additional properties added\r\n * // [[PromiseState]]; => Same as the `state` property\r\n * // [[PromiseResult]]; => The settled value\r\n * // [[PromiseIsHandled]] => Identifies if the promise has been handled\r\n * // It will also cause the `toString` for the promise to include additional\r\n * // debugging information\r\n * ```\r\n */\r\nexport function setPromiseDebugState(enabled: boolean, logger?: (id: string, message: string) => void) {\r\n    _promiseDebugEnabled = enabled;\r\n    //#ifdef DEBUG\r\n    //#:(!DEBUG) _theLogger = logger;\r\n    //#endif\r\n}","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { REJECTED } from \"./constants\";\r\n\r\n/**\r\n * @ignore -- Don't include in the generated documentation\r\n * @internal\r\n */\r\nexport const enum ePromiseState {\r\n    Pending = 0,\r\n    Resolving = 1,\r\n    Resolved = 2,\r\n    Rejected = 3\r\n}\r\n\r\n/**\r\n * @ignore -- Don't include in the generated documentation\r\n * @internal\r\n */\r\nexport const STRING_STATES: string[] = /*#__PURE__*/[\r\n    \"pending\", \"resolving\", \"resolved\", REJECTED\r\n];\r\n","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { dumpObj, getDocument, getInst, ICachedValue, createCachedValue, safe } from \"@nevware21/ts-utils\";\r\n\r\nconst DISPATCH_EVENT = \"dispatchEvent\";\r\nlet _hasInitEvent: ICachedValue<boolean>;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Helper function to determine if the document has the `initEvent` function\r\n * @param doc - The document to check\r\n * @returns\r\n */\r\nfunction _hasInitEventFn(doc: Document) {\r\n    let evt: any;\r\n    if (doc && doc.createEvent) {\r\n        evt = doc.createEvent(\"Event\");\r\n    }\r\n    \r\n    return (!!evt && evt.initEvent);\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * @param target\r\n * @param evtName\r\n * @param populateEvent\r\n * @param useNewEvent\r\n */\r\nexport function emitEvent(target: any, evtName: string, populateEvent: (theEvt: Event | any) => Event | any, useNewEvent: boolean) {\r\n\r\n    let doc = getDocument();\r\n    !_hasInitEvent && (_hasInitEvent = createCachedValue(!!safe(_hasInitEventFn, [ doc ]).v));\r\n\r\n    let theEvt: Event = _hasInitEvent.v ? doc.createEvent(\"Event\") : (useNewEvent ? new Event(evtName) : {} as Event);\r\n    populateEvent && populateEvent(theEvt);\r\n\r\n    if (_hasInitEvent.v) {\r\n        theEvt.initEvent(evtName, false, true);\r\n    }\r\n\r\n    if (theEvt && target[DISPATCH_EVENT]) {\r\n        target[DISPATCH_EVENT](theEvt);\r\n    } else {\r\n        let handler = target[\"on\" + evtName];\r\n        if (handler) {\r\n            handler(theEvt);\r\n        } else {\r\n            let theConsole = getInst(\"console\");\r\n            theConsole && (theConsole[\"error\"] || theConsole[\"log\"])(evtName, dumpObj(theEvt));\r\n        }\r\n    }\r\n}\r\n","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport {\r\n    arrSlice, dumpObj, getKnownSymbol, hasSymbol, isFunction, isPromiseLike, isUndefined,\r\n    throwTypeError, WellKnownSymbols, objToString, scheduleTimeout, ITimerHandler, getWindow, isNode,\r\n    getGlobal, objDefine, objDefineProp, iterForOf, isIterable, isArray, arrForEach, createCachedValue,\r\n    ICachedValue, safe, getInst, createCustomError\r\n} from \"@nevware21/ts-utils\";\r\nimport { doAwait, doAwaitResponse } from \"./await\";\r\nimport { _addDebugState, _promiseDebugEnabled } from \"./debug\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { PromisePendingProcessor } from \"./itemProcessor\";\r\nimport {\r\n    FinallyPromiseHandler, PromiseCreatorFn, PromiseExecutor, RejectedPromiseHandler, ResolvedPromiseHandler\r\n} from \"../interfaces/types\";\r\nimport { ePromiseState, STRING_STATES } from \"../internal/state\";\r\nimport { emitEvent } from \"./event\";\r\nimport { REJECTED, STR_PROMISE } from \"../internal/constants\";\r\nimport { IPromiseResult } from \"../interfaces/IPromiseResult\";\r\n\r\n//#ifdef DEBUG\r\n//#:(!DEBUG) import { _debugLog } from \"./debug\";\r\n//#endif\r\n\r\nconst NODE_UNHANDLED_REJECTION = \"unhandledRejection\";\r\nconst UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase();\r\n\r\nlet _currentPromiseId: number[] = [];\r\nlet _uniquePromiseId = 0;\r\nlet _unhandledRejectionTimeout = 10;\r\nlet _aggregationError: ICachedValue<any>;\r\n\r\n/**\r\n * [MDN Reference](https://developer.mozilla.org/docs/Web/API/PromiseRejectionEvent)\r\n */\r\ninterface _PromiseRejectionEvent extends Event {\r\n    /**\r\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/PromiseRejectionEvent/promise)\r\n     */\r\n    readonly promise: IPromise<any>;\r\n\r\n    /**\r\n     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/PromiseRejectionEvent/reason)\r\n     */\r\n    readonly reason: any;\r\n}\r\n\r\nlet _hasPromiseRejectionEvent: ICachedValue<_PromiseRejectionEvent>;\r\n\r\nfunction dumpFnObj(value: any) {\r\n    if (isFunction(value)) {\r\n        return value.toString();\r\n    }\r\n\r\n    return dumpObj(value);\r\n}\r\n\r\n//#ifdef DEBUG\r\n//#:(!DEBUG) function _getCaller(prefix: string, start: number) {\r\n//#:(!DEBUG)     let stack = new Error().stack;\r\n//#:(!DEBUG)     if (stack) {\r\n//#:(!DEBUG)         let lines = stack.split(\"\\n\");\r\n//#:(!DEBUG)         if (lines.length > start) {\r\n//#:(!DEBUG)             return prefix + \":\" + arrSlice(lines, start, start + 5).join(\"\\n\") + \"\\n...\";\r\n//#:(!DEBUG)         }\r\n//#:(!DEBUG)     }\r\n//#:(!DEBUG)     return null;\r\n//#:(!DEBUG) }\r\n//#endif\r\n\r\n/*#__NO_SIDE_EFFECTS__*/\r\nfunction _createAggregationError(values: any[]) {\r\n    !_aggregationError && (_aggregationError = createCachedValue(safe(getInst, [\"AggregationError\"]).v || createCustomError(\"AggregationError\", (self, args) => {\r\n        self.errors = args[0];\r\n    })));\r\n\r\n    return new _aggregationError.v(values);\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n *\r\n * Implementing a simple synchronous promise interface for support within any environment that\r\n * doesn't support the Promise API\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param processor - The function to use to process the pending\r\n * @param executor - The resolve function\r\n * @param additionalArgs - [Optional] Additional arguments that will be passed to the PromiseCreatorFn\r\n */\r\nexport function _createPromise<T>(newPromise: PromiseCreatorFn, processor: PromisePendingProcessor, executor: PromiseExecutor<T>, ...additionalArgs: any): IPromise<T>;\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n *\r\n * Implementing a simple synchronous promise interface for support within any environment that\r\n * doesn't support the Promise API\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param processor - The function to use to process the pending\r\n * @param executor - The resolve function\r\n * @param additionalArgs - [Optional] Additional arguments that will be passed to the PromiseCreatorFn\r\n */\r\nexport function _createPromise<T>(newPromise: PromiseCreatorFn, processor: PromisePendingProcessor, executor: PromiseExecutor<T>): IPromise<T> {\r\n    let additionalArgs = arrSlice(arguments, 3);\r\n    let _state = ePromiseState.Pending;\r\n    let _hasResolved = false;\r\n    let _settledValue: T;\r\n    let _queue: (() => void)[] = [];\r\n    let _id = _uniquePromiseId++;\r\n    let _parentId = _currentPromiseId.length > 0 ? _currentPromiseId[_currentPromiseId.length - 1] : undefined;\r\n    let _handled = false;\r\n    let _unHandledRejectionHandler: ITimerHandler = null;\r\n    let _thePromise: IPromise<T>;\r\n    \r\n    // https://tc39.es/ecma262/#sec-promise.prototype.then\r\n    function _then<TResult1 = T, TResult2 = never>(onResolved?: ResolvedPromiseHandler<T, TResult1>, onRejected?: RejectedPromiseHandler<TResult2>): IPromise<TResult1 | TResult2> {\r\n        try {\r\n            _currentPromiseId.push(_id);\r\n            _handled = true;\r\n            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();\r\n            _unHandledRejectionHandler = null;\r\n\r\n            let thenPromise = newPromise<TResult1, TResult2>(function (resolve, reject) {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), _getCaller(\"_then\", 7));\r\n                //#endif\r\n\r\n                // Queue the new promise returned to be resolved or rejected\r\n                // when this promise settles.\r\n                _queue.push(function () {\r\n                    // https://tc39.es/ecma262/#sec-newpromisereactionjob\r\n                    //let value: any;\r\n                    try {\r\n                        // First call the onFulfilled or onRejected handler, on the settled value\r\n                        // of this promise. If the corresponding `handler` does not exist, simply\r\n                        // pass through the settled value.\r\n                        //#ifdef DEBUG\r\n                        //#:(!DEBUG) _debugLog(_toString(), \"Handling settled value \" + dumpFnObj(_settledValue));\r\n                        //#endif\r\n                        let handler = _state === ePromiseState.Resolved ? onResolved : onRejected;\r\n                        let value = isUndefined(handler) ? _settledValue : (isFunction(handler) ? handler(_settledValue) : handler);\r\n                        //#ifdef DEBUG\r\n                        //#:(!DEBUG) _debugLog(_toString(), \"Handling Result \" + dumpFnObj(value));\r\n                        //#endif\r\n    \r\n                        if (isPromiseLike(value)) {\r\n                            // The called handlers returned a new promise, so the chained promise\r\n                            // will follow the state of this promise.\r\n                            value.then(resolve as any, reject);\r\n                        } else if (handler) {\r\n                            // If we have a handler then chained promises are always \"resolved\" with the result returned\r\n                            resolve(value as any);\r\n                        } else if (_state === ePromiseState.Rejected) {\r\n                            // If this promise is rejected then the chained promise should be rejected\r\n                            // with either the settled value of this promise or the return value of the handler.\r\n                            reject(value);\r\n                        } else {\r\n                            // If this promise is fulfilled, then the chained promise is also fulfilled\r\n                            // with either the settled value of this promise or the return value of the handler.\r\n                            resolve(value as any);\r\n                        }\r\n                    } catch (e) {\r\n                        reject(e);\r\n                    }\r\n                });\r\n    \r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Added to Queue \" + _queue.length);\r\n                //#endif\r\n    \r\n                // If this promise is already settled, then immediately process the callback we\r\n                // just added to the queue.\r\n                if (_hasResolved) {\r\n                    _processQueue();\r\n                }\r\n            }, additionalArgs);\r\n    \r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Created -> \" + thenPromise.toString());\r\n            //#endif\r\n    \r\n            return thenPromise;\r\n    \r\n        } finally {\r\n            _currentPromiseId.pop();\r\n        }\r\n    }\r\n\r\n    // https://tc39.es/ecma262/#sec-promise.prototype.catch\r\n    function _catch<TResult1 = T>(onRejected: RejectedPromiseHandler<TResult1>) {\r\n        // Reuse then onRejected to support rejection\r\n        return _then(undefined, onRejected);\r\n    }\r\n\r\n    // https://tc39.es/ecma262/#sec-promise.prototype.finally\r\n    function _finally<TResult1 = T, TResult2 = never>(onFinally: FinallyPromiseHandler): IPromise<TResult1 | TResult2> {\r\n        let thenFinally: any = onFinally;\r\n        let catchFinally: any = onFinally;\r\n        if (isFunction(onFinally)) {\r\n            thenFinally = function(value: TResult1 | TResult2) {\r\n                onFinally && onFinally();\r\n                return value;\r\n            }\r\n    \r\n            catchFinally = function(reason: any) {\r\n                onFinally && onFinally();\r\n                throw reason;\r\n            }\r\n        }\r\n\r\n        return _then<TResult1, TResult2>(thenFinally as any, catchFinally as any);\r\n    }\r\n\r\n    function _strState() {\r\n        return STRING_STATES[_state];\r\n    }\r\n\r\n    function _processQueue() {\r\n        if (_queue.length > 0) {\r\n            // The onFulfilled and onRejected handlers must be called asynchronously. Thus,\r\n            // we make a copy of the queue and work on it once the current call stack unwinds.\r\n            let pending = _queue.slice();\r\n            _queue = [];\r\n\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Processing queue \" + pending.length);\r\n            //#endif\r\n\r\n            _handled = true;\r\n            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();\r\n            _unHandledRejectionHandler = null;\r\n            processor(pending);\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Processing done\");\r\n            //#endif\r\n\r\n        } else {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Empty Processing queue \");\r\n            //#endif\r\n        }\r\n    }\r\n\r\n    function _createSettleIfFn(newState: ePromiseState, allowState: ePromiseState) {\r\n        return (theValue: T) => {\r\n            if (_state === allowState) {\r\n                if (newState === ePromiseState.Resolved && isPromiseLike(theValue)) {\r\n                    _state = ePromiseState.Resolving;\r\n                    //#ifdef DEBUG\r\n                    //#:(!DEBUG) _debugLog(_toString(), \"Resolving\");\r\n                    //#endif\r\n                    theValue.then(\r\n                        _createSettleIfFn(ePromiseState.Resolved, ePromiseState.Resolving),\r\n                        _createSettleIfFn(ePromiseState.Rejected, ePromiseState.Resolving));\r\n                    return;\r\n                }\r\n\r\n                _state = newState;\r\n                _hasResolved = true;\r\n                _settledValue = theValue;\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), _strState());\r\n                //#endif\r\n                _processQueue();\r\n                if (!_handled && newState === ePromiseState.Rejected && !_unHandledRejectionHandler) {\r\n                    //#ifdef DEBUG\r\n                    //#:(!DEBUG) _debugLog(_toString(), \"Setting up unhandled rejection\");\r\n                    //#endif\r\n                    _unHandledRejectionHandler = scheduleTimeout(_notifyUnhandledRejection, _unhandledRejectionTimeout)\r\n                }\r\n            } else {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Already \" + _strState());\r\n                //#endif\r\n            }\r\n        };\r\n    }\r\n\r\n    function _notifyUnhandledRejection() {\r\n        if (!_handled) {\r\n            // Mark as handled so we don't keep notifying\r\n            _handled = true;\r\n            if (isNode()) {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Emitting \" + NODE_UNHANDLED_REJECTION);\r\n                //#endif\r\n                process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise);\r\n            } else {\r\n                let gbl = getWindow() || getGlobal();\r\n    \r\n                !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = createCachedValue(safe(getInst<_PromiseRejectionEvent>, [STR_PROMISE + \"RejectionEvent\"]).v));\r\n\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Emitting \" + UNHANDLED_REJECTION);\r\n                //#endif\r\n                emitEvent(gbl, UNHANDLED_REJECTION, (theEvt: any) => {\r\n                    objDefine(theEvt, \"promise\", { g: () => _thePromise });\r\n                    theEvt.reason = _settledValue;\r\n                    return theEvt;\r\n                }, !!_hasPromiseRejectionEvent.v);\r\n            }\r\n        }\r\n    }\r\n\r\n    _thePromise = {\r\n        then: _then,\r\n        \"catch\": _catch,\r\n        finally: _finally\r\n    } as any;\r\n\r\n    objDefineProp(_thePromise, \"state\", {\r\n        get: _strState\r\n    });\r\n\r\n    if (_promiseDebugEnabled) {\r\n        // eslint-disable-next-line brace-style\r\n        _addDebugState(_thePromise, _strState, () => { return objToString(_settledValue); }, () => _handled);\r\n    }\r\n\r\n    if (hasSymbol()) {\r\n        _thePromise[getKnownSymbol<symbol>(WellKnownSymbols.toStringTag)] = \"IPromise\";\r\n    }\r\n\r\n    let createStack: string;\r\n    //#if DEBUG\r\n    //#:(!{DEBUG}) createStack = _getCaller(\"Created\", 5);\r\n    //#endif\r\n    function _toString() {\r\n        return \"IPromise\" + (_promiseDebugEnabled ? \"[\" + _id + (!isUndefined(_parentId) ? (\":\" + _parentId) : \"\") + \"]\" : \"\") + \" \" + _strState() + (_hasResolved ? (\" - \" + dumpFnObj(_settledValue)) : \"\") + (createStack ? \" @ \" + createStack : \"\");\r\n    }\r\n\r\n    _thePromise.toString = _toString;\r\n\r\n    (function _initialize() {\r\n        if (!isFunction(executor)) {\r\n            throwTypeError(STR_PROMISE + \": executor is not a function - \" + dumpFnObj(executor));\r\n        }\r\n\r\n        const _rejectFn = _createSettleIfFn(ePromiseState.Rejected, ePromiseState.Pending);\r\n        try {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Executing\");\r\n            //#endif\r\n            executor.call(\r\n                _thePromise,\r\n                _createSettleIfFn(ePromiseState.Resolved, ePromiseState.Pending),\r\n                _rejectFn);\r\n        } catch (e) {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Exception thrown: \" + dumpFnObj(e));\r\n            //#endif\r\n            _rejectFn(e);\r\n        }\r\n\r\n        //#ifdef DEBUG\r\n        //#:(!DEBUG) _debugLog(_toString(), \"~Executing\");\r\n        //#endif\r\n    })();\r\n\r\n    //#ifdef DEBUG\r\n    //#:(!DEBUG) _debugLog(_toString(), \"Returning\");\r\n    //#endif\r\n    return _thePromise;\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n * Returns a function which when called will return a new Promise object that resolves to an array of the\r\n * results from the input promises. The returned promise will resolve when all of the inputs' promises have\r\n * resolved, or if the input contains no promises. It rejects immediately upon any of the input promises\r\n * rejected or non-promises throwing an error, and will reject with this first rejection message / error.\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will be resolved when all arguments are resolved.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createAllPromise(newPromise: PromiseCreatorFn): <T>(input: Iterable<T | PromiseLike<T>>, ...additionalArgs: any) => IPromise<Awaited<T>[]> {\r\n    return function <T>(input: Iterable<T | PromiseLike<T>>): IPromise<Awaited<T>[]> {\r\n        let additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise<Awaited<T>[]>((resolve, reject) => {\r\n            try {\r\n                let values = [] as any;\r\n                let pending = 1;            // Prefix to 1 so we finish iterating over all of the input promises first\r\n\r\n                iterForOf(input, (item, idx) => {\r\n                    if (item) {\r\n                        pending++;\r\n                        doAwait(item, (value) => {\r\n                            // Set the result values\r\n                            values[idx] = value;\r\n                            if (--pending === 0) {\r\n                                resolve(values);\r\n                            }\r\n                        }, reject);\r\n                    }\r\n                });\r\n\r\n                // Now decrement the pending so that we finish correctly\r\n                pending--;\r\n                if (pending === 0) {\r\n                    // All promises were either resolved or where not a promise\r\n                    resolve(values);\r\n                }\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    };\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n * The createResolvedPromise returns a PromiseLike object that is resolved with a given value. If the value is\r\n * PromiseLike (i.e. has a \"then\" method), the returned promise will \"follow\" that thenable, adopting its eventual\r\n * state; otherwise the returned promise will be fulfilled with the value. This function flattens nested layers\r\n * of promise-like objects (e.g. a promise that resolves to a promise that resolves to something) into a single layer.\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param value - Argument to be resolved by this Promise. Can also be a Promise or a thenable to resolve.\r\n * @param additionalArgs - Any additional arguments that should be passed to the delegate to assist with the creation of\r\n * the new promise instance.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createResolvedPromise(newPromise: PromiseCreatorFn): <T>(value: T, ...additionalArgs: any) => IPromise<T> {\r\n    return function <T>(value: T): IPromise<T> {\r\n        let additionalArgs = arrSlice(arguments, 1);\r\n        if (isPromiseLike<T>(value)) {\r\n            return value as unknown as IPromise<T>;\r\n        }\r\n    \r\n        return newPromise((resolve) => {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(String(this), \"Resolving Promise\");\r\n            //#endif\r\n            resolve(value);\r\n        }, additionalArgs);\r\n    };\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n * Return a promise like object that is rejected with the given reason.\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param reason - The rejection reason\r\n * @param additionalArgs - Any additional arguments that should be passed to the delegate to assist with the creation of\r\n * the new promise instance.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createRejectedPromise(newPromise: PromiseCreatorFn): <T>(reason: any, ...additionalArgs: any) => IPromise<T> {\r\n    return function <T>(reason: any): IPromise<T> {\r\n        let additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise((_resolve, reject) => {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(String(this), \"Rejecting Promise\");\r\n            //#endif\r\n            reject(reason);\r\n        }, additionalArgs);\r\n    };\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n * @since 0.5.0\r\n * Returns a function which when called will return a new Promise object that resolves to an array of\r\n * IPromiseResults from the input promises. The returned promise will resolve when all of the inputs'\r\n * promises have resolved or rejected, or if the input contains no promises. It will resolve only after\r\n * all input promises have been fulfilled (resolve or rejected).\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will be resolved when all arguments are resolved.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createAllSettledPromise(newPromise: PromiseCreatorFn, ..._args: any[]): ICachedValue<<T extends readonly unknown[] | []>(input: T, timeout?: number) => IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }>> {\r\n    return createCachedValue(function <T>(input: T, ..._args: any[]): IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }> {\r\n        let additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }>((resolve, reject) => {\r\n            let values: { -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; } = [] as any;\r\n            let pending = 1;            // Prefix to 1 so we finish iterating over all of the input promises first\r\n\r\n            function processItem(item: any, idx: number) {\r\n                pending++;\r\n                doAwaitResponse(item, (value) => {\r\n                    if (value.rejected) {\r\n                        values[idx] = {\r\n                            status: REJECTED,\r\n                            reason: value.reason\r\n                        };\r\n                    } else {\r\n                        values[idx] = {\r\n                            status: \"fulfilled\",\r\n                            value: value.value\r\n                        };\r\n                    }\r\n                \r\n                    if (--pending === 0) {\r\n                        resolve(values);\r\n                    }\r\n                });\r\n            }\r\n\r\n            try {\r\n\r\n                if (isArray(input)) {\r\n                    arrForEach(input, processItem);\r\n                } else if (isIterable(input)) {\r\n                    iterForOf(input, processItem);\r\n                } else {\r\n                    throwTypeError(\"Input is not an iterable\");\r\n                }\r\n\r\n                // Now decrement the pending so that we finish correctly\r\n                pending--;\r\n                if (pending === 0) {\r\n                    // All promises were either resolved or where not a promise\r\n                    resolve(values);\r\n                }\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    });\r\n}\r\n\r\n/**\r\n * @ignore\r\n * @internal\r\n * @since 0.5.0\r\n * Returns a function takes an iterable of promises as input and returns a single Promise.\r\n * This returned promise settles with the eventual state of the first promise that settles.\r\n * @description The returned promise is one of the promise concurrency methods. It's useful when you want\r\n * the first async task to complete, but do not care about its eventual state (i.e. it can either succeed\r\n * or fail).\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will resolve when the first promise to settle is fulfilled,\r\n * and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises,\r\n * the returned promise is still settled.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function  _createRacePromise(newPromise: PromiseCreatorFn, ..._args: any[]): ICachedValue<<T extends readonly unknown[] | []>(values: T, timeout?: number) => IPromise<Awaited<T[number]>>> {\r\n    return createCachedValue(function <T extends readonly unknown[] | []>(input: T, ..._args: any[]): IPromise<Awaited<T[number]>> {\r\n        let additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise<Awaited<T[number]>>((resolve, reject) => {\r\n            let isDone = false;\r\n\r\n            function processItem(item: any) {\r\n                doAwaitResponse(item, (value) => {\r\n                    if (!isDone) {\r\n                        isDone = true;\r\n                        if (value.rejected) {\r\n                            reject(value.reason);\r\n                        } else {\r\n                            resolve(value.value);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n\r\n            try {\r\n                if (isArray(input)) {\r\n                    arrForEach(input, processItem);\r\n                } else if (isIterable(input)) {\r\n                    iterForOf(input, processItem);\r\n                } else {\r\n                    throwTypeError(\"Input is not an iterable\");\r\n                }\r\n\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    });\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * @since 0.5.0\r\n * Returns a function takes an iterable of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment\r\n * value. It rejects when all of the input's promises reject (including when an empty iterable is passed),\r\n * with an AggregateError containing an array of rejection reasons.\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will resolve when the any of the input's promises fulfills,\r\n * with this first fulfillment value. It rejects when all of the input's promises reject (including when\r\n * an empty iterable is passed), with an AggregateError containing an array of rejection reasons.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function  _createAnyPromise(newPromise: PromiseCreatorFn, ..._args: any[]): ICachedValue<<T extends readonly unknown[] | []>(values: T) => IPromise<Awaited<T[number]>>> {\r\n    return createCachedValue(function <T extends readonly unknown[] | []>(input: T, ..._args: any[]): IPromise<Awaited<T[number]>> {\r\n        let additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise<Awaited<T[number]>>((resolve, reject) => {\r\n            let theErros: Array<any> = [] as any;\r\n            let pending = 1;            // Prefix to 1 so we finish iterating over all of the input promises first\r\n            let isDone = false;\r\n\r\n            function processItem(item: any, idx: number) {\r\n                pending++;\r\n                doAwaitResponse(item, (value ) => {\r\n                    if (!value.rejected) {\r\n                        isDone = true;\r\n                        resolve(value.value);\r\n                        return;\r\n                    } else {\r\n                        theErros[idx] = value.reason;\r\n                    }\r\n\r\n                    if (--pending === 0 && !isDone) {\r\n                        reject(_createAggregationError(theErros));\r\n                    }\r\n                });\r\n            }\r\n\r\n            try {\r\n                if (isArray(input)) {\r\n                    arrForEach(input, processItem);\r\n                } else if (isIterable(input)) {\r\n                    iterForOf(input, processItem);\r\n                } else {\r\n                    throwTypeError(\"Input is not an iterable\");\r\n                }\r\n\r\n                // Now decrement the pending so that we finish correctly\r\n                pending--;\r\n                if (pending === 0 && !isDone) {\r\n                    // All promises were either resolved or where not a promise\r\n                    reject(_createAggregationError(theErros));\r\n                }\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    });\r\n}\r\n","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { arrForEach, isNumber, scheduleIdleCallback, scheduleTimeout } from \"@nevware21/ts-utils\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { PromiseExecutor } from \"../interfaces/types\";\r\n\r\nexport type PromisePendingProcessor = (pending: PromisePendingFn[]) => void;\r\nexport type PromisePendingFn = () => void;\r\nexport type PromiseCreatorFn = <T, TResult2 = never>(newExecutor: PromiseExecutor<T>, ...extraArgs: any) => IPromise<T | TResult2>;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Return an item processor that processes all of the pending items synchronously\r\n * @return An item processor\r\n */\r\nexport function syncItemProcessor(pending: PromisePendingFn[]): void {\r\n    arrForEach(pending, (fn: PromisePendingFn) => {\r\n        try {\r\n            fn();\r\n        } catch (e) {\r\n            // Don't let 1 failing handler break all others\r\n            // TODO: Add some form of error reporting (i.e. Call any registered JS error handler so the error is reported)\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Return an item processor that processes all of the pending items asynchronously using the optional timeout.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n * @return An item processor\r\n */\r\nexport function timeoutItemProcessor(timeout?: number): (pending: PromisePendingFn[]) => void {\r\n    let callbackTimeout = isNumber(timeout) ? timeout : 0;\r\n\r\n    return (pending: PromisePendingFn[]) => {\r\n        scheduleTimeout(() => {\r\n            syncItemProcessor(pending);\r\n        }, callbackTimeout);\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Return an item processor that processes all of the pending items using an idle callback (if available) or based on\r\n * a timeout (when `requestIdenCallback` is not supported) using the optional timeout.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n * @return An item processor\r\n */\r\nexport function idleItemProcessor(timeout?: number): (pending: PromisePendingFn[]) => void {\r\n    let options: any;\r\n    if (timeout >= 0) {\r\n        options = {\r\n            timeout: +timeout\r\n        };\r\n    }\r\n\r\n    return (pending: PromisePendingFn[]) => {\r\n        scheduleIdleCallback((deadline: IdleDeadline) => {\r\n            syncItemProcessor(pending);\r\n        }, options);\r\n    };\r\n}","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport {\r\n    _createAllPromise, _createAllSettledPromise, _createAnyPromise, _createPromise, _createRacePromise,\r\n    _createRejectedPromise, _createResolvedPromise\r\n} from \"./base\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { timeoutItemProcessor } from \"./itemProcessor\";\r\nimport { PromiseExecutor } from \"../interfaces/types\";\r\nimport { IPromiseResult } from \"../interfaces/IPromiseResult\";\r\nimport { ICachedValue } from \"@nevware21/ts-utils\";\r\n\r\nlet _allAsyncSettledCreator: ICachedValue<<T extends readonly unknown[] | []>(input: T, timeout?: number) => IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }>>;\r\nlet _raceAsyncCreator: ICachedValue<<T extends readonly unknown[] | []>(values: T, timeout?: number) => IPromise<Awaited<T[number]>>>;\r\nlet _anyAsyncCreator: ICachedValue<<T extends readonly unknown[] | []>(values: T, timeout?: number) => IPromise<Awaited<T[number]>>>;\r\n\r\n/**\r\n * Creates an asynchronous Promise instance that when resolved or rejected will execute it's pending chained operations\r\n * __asynchronously__ using the optional provided timeout value to schedule when the chained items will be ececuted.\r\n * @group Async\r\n * @group Promise\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport function createAsyncPromise<T>(executor: PromiseExecutor<T>, timeout?: number): IPromise<T> {\r\n    return _createPromise(createAsyncPromise, timeoutItemProcessor(timeout), executor, timeout);\r\n}\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __asynchronously__ using the optional\r\n * provided timeout value to schedule when the chained items will be executed, or if the input contains no promises.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * When resolved or rejected any additional chained operations will execute __asynchronously__ using the optional\r\n * timeout value to schedul when the chained item will be executed (eg. `then()`; `catch()`; `finally()`).\r\n * @group Async\r\n * @group Promise\r\n * @group All\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport const createAsyncAllPromise: <T>(input: Iterable<PromiseLike<T>>, timeout?: number) => IPromise<T[]> = /*#__PURE__*/_createAllPromise(createAsyncPromise);\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __asynchronously__ using the optional\r\n * timeout value to schedule when the chained items will be executed.(eg. `then()`; `finally()`).\r\n * @group Async\r\n * @group Promise\r\n * @group Resolved\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport const createAsyncResolvedPromise: <T>(value: T, timeout?: number) => IPromise<T> = /*#__PURE__*/_createResolvedPromise(createAsyncPromise);\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __asynchronously__ using the optional timeout value to schedule\r\n * when then chained items will be executed. (eg. `catch()`; `finally()`).\r\n * @group Async\r\n * @group Promise\r\n * @group Rejected\r\n * @param reason - The rejection reason\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport const createAsyncRejectedPromise: <T = unknown>(reason: any, timeout?: number) => IPromise<T> = /*#__PURE__*/_createRejectedPromise(createAsyncPromise);\r\n\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the\r\n * {@link createAsyncPromise | Asynchronous} promise implementation. Any chained operations will execute\r\n * __asynchronously__  when the final operation pending promises have resolved, or if the input contains\r\n * no promises. It will resolve only after all of the input promises have either resolved or rejected,\r\n * and will resolve with an array of {@link IPromiseResult } objects that each describe the outcome of\r\n * each promise.\r\n * @since 0.5.0\r\n * @group Async\r\n * @group Promise\r\n * @group AllSettled\r\n * @param values - The iterator of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createAsyncAllSettledPromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<IPromiseResult<Awaited<T>>[]>;\r\n\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the\r\n * {@link createAsyncPromise | Asynchronous} promise implementation. Any chained operations will execute\r\n * __asynchronously__  when the final operation pending promises have resolved, or if the input contains\r\n * no promises. It will resolve only after all of the input promises have either resolved or rejected,\r\n * and will resolve with an array of {@link IPromiseResult } objects that each describe the outcome of\r\n * each promise.\r\n * @since 0.5.0\r\n * @group Async\r\n * @group Promise\r\n * @group AllSettled\r\n * @param input - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createAsyncAllSettledPromise<T extends readonly unknown[] | []>(input: T, timeout?: number): IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }> {\r\n    !_allAsyncSettledCreator && (_allAsyncSettledCreator = _createAllSettledPromise(createAsyncPromise));\r\n    return _allAsyncSettledCreator.v(input, timeout);\r\n}\r\n\r\n/**\r\n * The `createAsyncRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createAsyncRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Async\r\n * @group Promise\r\n * @group Race\r\n * @param values - An iterable object of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise is still\r\n * asynchronously settled.\r\n */\r\nexport function createAsyncRacePromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n\r\n/**\r\n * The `createAsyncRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createAsyncRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Async\r\n * @group Promise\r\n * @group Race\r\n * @param values - An the array of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise is still\r\n * asynchronously settled.\r\n */\r\nexport function  createAsyncRacePromise<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>> {\r\n    !_raceAsyncCreator && (_raceAsyncCreator = _createRacePromise(createAsyncPromise));\r\n    return _raceAsyncCreator.v(values, timeout);\r\n}\r\n\r\n/**\r\n * The `createAsyncAnyPromise` method takes an iterable of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Async\r\n * @group Promise\r\n * @group Any\r\n * @param values - An iterable object of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createAsyncAnyPromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n        \r\n/**\r\n * The `createAsyncAnyPromise` method takes an array of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Async\r\n * @group Promise\r\n * @group Any\r\n * @param values - An Array promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createAsyncAnyPromise<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>> {\r\n    !_anyAsyncCreator && (_anyAsyncCreator = _createAnyPromise(createAsyncPromise));\r\n    return _anyAsyncCreator.v(values, timeout);\r\n}","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { createAsyncPromise } from \"./asyncPromise\";\r\nimport { _createAllPromise, _createAllSettledPromise, _createAnyPromise, _createRacePromise, _createRejectedPromise, _createResolvedPromise } from \"./base\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { ePromiseState, STRING_STATES } from \"../internal/state\";\r\nimport { PromiseExecutor } from \"../interfaces/types\";\r\nimport { dumpObj, isFunction, objDefineProp, throwTypeError, getInst, ICachedValue, createCachedValue, safe } from \"@nevware21/ts-utils\";\r\nimport { STR_PROMISE } from \"../internal/constants\";\r\nimport { IPromiseResult } from \"../interfaces/IPromiseResult\";\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Flag to determine if the native Promise class should be used if available, used for testing purposes.\r\n */\r\nlet _useNative: boolean = true;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the native Promise class\r\n */\r\nlet _promiseCls: ICachedValue<PromiseConstructor>;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the `Promise.all` method\r\n */\r\nlet _allCreator: ICachedValue<<T>(input: Iterable<T | PromiseLike<T>>, ...additionalArgs: any) => IPromise<Awaited<T>[]>>;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the `Promise.allSettled` method\r\n */\r\nlet _allNativeSettledCreator: ICachedValue<<T extends readonly unknown[] | []>(input: T, timeout?: number) => IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }>>;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the `Promise.race` method\r\n */\r\nlet _raceNativeCreator: ICachedValue<<T extends readonly unknown[] | []>(values: T, timeout?: number) => IPromise<Awaited<T[number]>>>;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the `Promise.any` method\r\n */\r\nlet _anyNativeCreator: ICachedValue<<T extends readonly unknown[] | []>(values: T, timeout?: number) => IPromise<Awaited<T[number]>>>;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Test Hook function to clear the cached values and set whether to use the native Promise class\r\n * @param useNative - Flag to determine if the native Promise class should be used if available\r\n */\r\nexport function _clearPromiseCache(useNative: boolean) {\r\n//#ifdef _DEBUG\r\n//#:(!_DEBUG)     _useNative = !!useNative;\r\n//#:(!_DEBUG)     _promiseCls = null as any;\r\n//#:(!_DEBUG)     _allCreator = null as any;\r\n//#:(!_DEBUG)     _allNativeSettledCreator = null as any;\r\n//#:(!_DEBUG)     _raceNativeCreator = null as any;\r\n//#:(!_DEBUG)     _anyNativeCreator = null as any;\r\n//#endif\r\n}\r\n\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createNativePromiseHelper<F>(name: string, func: () => ICachedValue<F>): ICachedValue<F> {\r\n    !_promiseCls && (_promiseCls = createCachedValue<PromiseConstructor>((_useNative && safe(getInst, [STR_PROMISE]).v) || null as any));\r\n    if (_promiseCls.v && _promiseCls.v[name]) {\r\n        return createCachedValue(function<T extends readonly unknown[] | []>(input: T, timeout?: number) {\r\n            return createNativePromise((resolve, reject) => {\r\n                _promiseCls.v[name](input).then(resolve, reject);\r\n            });\r\n        } as F);\r\n    }\r\n    \r\n    return func();\r\n}\r\n\r\n/**\r\n * Creates a Promise instance that when resolved or rejected will execute it's pending chained operations using the\r\n * available native Promise implementation.\r\n * If runtime does not support native `Promise` class (or no polyfill is available) this function will fallback to using\r\n * `createAsyncPromise` which will resolve them __asynchronously__ using the optional provided timeout value to\r\n * schedule when the chained items will be executed.\r\n * @group Alias\r\n * @group Promise\r\n * @group Native\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport function createNativePromise<T>(executor: PromiseExecutor<T>, timeout?: number): IPromise<T> {\r\n    !_promiseCls && (_promiseCls = createCachedValue<PromiseConstructor>((_useNative && safe(getInst, [STR_PROMISE]).v) || null as any));\r\n    const PrmCls = _promiseCls.v;\r\n    if (!PrmCls) {\r\n        return createAsyncPromise(executor);\r\n    }\r\n\r\n    if (!isFunction(executor)) {\r\n        throwTypeError(STR_PROMISE + \": executor is not a function - \" + dumpObj(executor));\r\n    }\r\n\r\n    let _state = ePromiseState.Pending;\r\n\r\n    function _strState() {\r\n        return STRING_STATES[_state];\r\n    }\r\n\r\n    let thePromise = new PrmCls<T>((resolve, reject) => {\r\n        function _resolve(value: T) {\r\n            _state = ePromiseState.Resolved;\r\n            resolve(value);\r\n        }\r\n\r\n        function _reject(reason: any) {\r\n            _state = ePromiseState.Rejected;\r\n            reject(reason);\r\n        }\r\n\r\n        executor(_resolve, _reject);\r\n\r\n    }) as IPromise<T>;\r\n\r\n    objDefineProp(thePromise, \"state\", {\r\n        get: _strState\r\n    });\r\n\r\n    return thePromise;\r\n}\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __asynchronously__ using the optional\r\n * provided timeout value to schedule when the chained items will be executed, or if the input contains no promises.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * If the runtime doesn't support the Promise.all it will fallback back to an asynchronous Promise implementation.\r\n * @group Alias\r\n * @group Promise\r\n * @group All\r\n * @group Native\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport function createNativeAllPromise<T>(input: Iterable<PromiseLike<T>>, timeout?: number): IPromise<T[]> {\r\n    !_allCreator && (_allCreator = _createNativePromiseHelper(\"all\", () => createCachedValue(_createAllPromise(createNativePromise))));\r\n    return _allCreator.v(input, timeout);\r\n}\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __asynchronously__ using the optional\r\n * timeout value to schedule when the chained items will be executed.(eg. `then()`; `finally()`).\r\n * @group Alias\r\n * @group Promise\r\n * @group Resolved\r\n * @group Native\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport const createNativeResolvedPromise: <T>(value: T, timeout?: number) => Promise<T> =  /*#__PURE__*/_createResolvedPromise(createNativePromise);\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __asynchronously__ using the optional timeout value to schedule\r\n * when then chained items will be executed. (eg. `catch()`; `finally()`).\r\n * @group Alias\r\n * @group Promise\r\n * @group Rejected\r\n * @group Native\r\n * @param reason - The rejection reason\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport const createNativeRejectedPromise: <T = unknown>(reason: any, timeout?: number) => Promise<T> = /*#__PURE__*/_createRejectedPromise(createNativePromise);\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations using {@link createNativePromise | native}\r\n * environment promise implementation, if the runtime does not provide any native then the optional provided\r\n * timeout value will be used to schedule when the chained items will be executed or if the input contains no promises.\r\n * It will resolve only after all of the input promises have either resolved or rejected, and will resolve with an array\r\n * of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group AllSettled\r\n * @group Native\r\n * @param values - The iterator of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createNativeResolvedPromise(1),\r\n *   createNativeResolvedPromise(2),\r\n *   createNativeResolvedPromise(3),\r\n *   createNativeRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createNativeAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createNativeAllSettledPromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<IPromiseResult<Awaited<T>>[]>;\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations using {@link createNativePromise | native}\r\n * environment promise implementation, if the runtime does not provide any native then the optional provided\r\n * timeout value will be used to schedule when the chained items will be executed or if the input contains no promises.\r\n * It will resolve only after all of the input promises have either resolved or rejected, and will resolve with an array\r\n * of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group AllSettled\r\n * @group Native\r\n * @param input - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createNativeResolvedPromise(1),\r\n *   createNativeResolvedPromise(2),\r\n *   createNativeResolvedPromise(3),\r\n *   createNativeRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createNativeAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createNativeAllSettledPromise<T extends readonly unknown[] | []>(input: T, timeout?: number): IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }> {\r\n    !_allNativeSettledCreator && (_allNativeSettledCreator = _createNativePromiseHelper(\"allSettled\", () => _createAllSettledPromise(createNativePromise)));\r\n    return _allNativeSettledCreator.v(input, timeout);\r\n}\r\n\r\n/**\r\n * The `createNativeRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createNativeRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Race\r\n * @group Native\r\n * @param values - An iterable object of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * asynchronously.\r\n */\r\nexport function createNativeRacePromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n\r\n/**\r\n * The `createNativeRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createNativeRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Race\r\n * @group Native\r\n * @param values - An the array of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * asynchronously.\r\n */\r\nexport function  createNativeRacePromise<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>> {\r\n    !_raceNativeCreator && (_raceNativeCreator = _createNativePromiseHelper(\"race\", () => _createRacePromise(createNativePromise)));\r\n    return _raceNativeCreator.v(values, timeout);\r\n}\r\n\r\n/**\r\n * The `createNativeAnyPromise` method takes an iterable of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Any\r\n * @group Native\r\n * @param values - An iterable object of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createNativeAnyPromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n        \r\n/**\r\n * The `createNativeAnyPromise` method takes an array of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Any\r\n * @group Native\r\n * @param values - An Array promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createNativeAnyPromise<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>> {\r\n    !_anyNativeCreator && (_anyNativeCreator = _createNativePromiseHelper(\"any\", () => _createAnyPromise(createNativePromise)));\r\n    return _anyNativeCreator.v(values, timeout);\r\n}\r\n","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport {\r\n    _createAllPromise, _createAllSettledPromise, _createAnyPromise, _createPromise, _createRacePromise,\r\n    _createRejectedPromise, _createResolvedPromise\r\n} from \"./base\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { syncItemProcessor } from \"./itemProcessor\";\r\nimport { PromiseExecutor } from \"../interfaces/types\";\r\nimport { IPromiseResult } from \"../interfaces/IPromiseResult\";\r\nimport { ICachedValue } from \"@nevware21/ts-utils\";\r\n\r\nlet _allSyncSettledCreator: ICachedValue<<T extends readonly unknown[] | []>(input: T, timeout?: number) => IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }>>;\r\nlet _raceSyncCreator: ICachedValue<<T extends readonly unknown[] | []>(values: T, timeout?: number) => IPromise<Awaited<T[number]>>>;\r\nlet _anySyncCreator: ICachedValue<<T extends readonly unknown[] | []>(values: T, timeout?: number) => IPromise<Awaited<T[number]>>>;\r\n\r\n/**\r\n * Creates a synchronous Promise instance that when resolved or rejected will execute it's pending chained operations\r\n * __synchronously__ in the same execution cycle as the operation that calls the `executors`, `resolve` or `reject` functions.\r\n *\r\n * @group Synchronous\r\n * @group Promise\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n */\r\nexport function createSyncPromise<T>(executor: PromiseExecutor<T>): IPromise<T>  {\r\n    return _createPromise(createSyncPromise, syncItemProcessor, executor);\r\n}\r\n\r\n/**\r\n * Returns a single synchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __synchronously__ in the same\r\n * execution cycle as the final operation pending promises have resolved, or if the input contains no promises.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * When resolved or rejected any additional chained operations will execute __synchronously__ at the point of\r\n * being added (eg. `then()`; `catch()`; `finally()`).\r\n * @group Synchronous\r\n * @group Promise\r\n * @group All\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport const createSyncAllPromise: <T>(input: Iterable<PromiseLike<T>>) => IPromise<T[]> = /*#__PURE__*/_createAllPromise(createSyncPromise);\r\n\r\n/**\r\n * Returns a single synchronous Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new synchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __synchronously__ at the point of being\r\n * added (calling `then()`).\r\n * @group Synchronous\r\n * @group Promise\r\n * @group Resolved\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n */\r\nexport const createSyncResolvedPromise: <T>(value: T) => IPromise<T> = /*#__PURE__*/_createResolvedPromise(createSyncPromise);\r\n\r\n/**\r\n * Returns a single synchronous Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __synchronously__ at the point of being added (eg. `catch()`; `finally()`).\r\n * @group Synchronous\r\n * @group Promise\r\n * @group Rejected\r\n * @param reason - The rejection reason\r\n */\r\nexport const createSyncRejectedPromise: <T = unknown>(reason: any) => IPromise<T> = /*#__PURE__*/_createRejectedPromise(createSyncPromise);\r\n\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the\r\n * {@link createSyncPromise | synchronous} promise implementation. Any chained operations will execute\r\n * __synchronously__ in the same execution cycle as the final operation pending promises have resolved,\r\n * or if the input contains no promises. It will resolve only after all of the input promises have either\r\n * resolved or rejected, and will resolve with an array of {@link IPromiseResult } objects that each describe\r\n * the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Synchronous\r\n * @group Promise\r\n * @group AllSettled\r\n * @param values - The iterator of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createSyncAllSettledPromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<IPromiseResult<Awaited<T>>[]>;\r\n\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the\r\n * {@link createSyncPromise | synchronous} promise implementation. Any chained operations will execute\r\n * __synchronously__ in the same execution cycle as the final operation pending promises have resolved,\r\n * or if the input contains no promises. It will resolve only after all of the input promises have either\r\n * resolved or rejected, and will resolve with an array of {@link IPromiseResult } objects that each describe\r\n * the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Synchronous\r\n * @group Promise\r\n * @group AllSettled\r\n * @param input - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createSyncAllSettledPromise<T extends readonly unknown[] | []>(input: T, timeout?: number): IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }> {\r\n    !_allSyncSettledCreator && (_allSyncSettledCreator = _createAllSettledPromise(createSyncPromise));\r\n    return _allSyncSettledCreator.v(input, timeout);\r\n}\r\n\r\n/**\r\n * The `createSyncRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createSyncRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Synchronous\r\n * @group Promise\r\n * @group Race\r\n * @param values - An iterable object of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * synchronously.\r\n */\r\nexport function createSyncRacePromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n\r\n/**\r\n * The `createSyncRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createSyncRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Synchronous\r\n * @group Promise\r\n * @group Race\r\n * @param values - An the array of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * synchronously.\r\n */\r\nexport function  createSyncRacePromise<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>> {\r\n    !_raceSyncCreator && (_raceSyncCreator = _createRacePromise(createSyncPromise));\r\n    return _raceSyncCreator.v(values, timeout);\r\n}\r\n\r\n/**\r\n * The `createSyncAnyPromise` method takes an iterable of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Synchronous\r\n * @group Promise\r\n * @group Any\r\n * @param values - An iterable object of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createSyncAnyPromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n        \r\n/**\r\n * The `createSyncAnyPromise` method takes an array of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Synchronous\r\n * @group Promise\r\n * @group Any\r\n * @param values - An Array promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createSyncAnyPromise<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>> {\r\n    !_anySyncCreator && (_anySyncCreator = _createAnyPromise(createSyncPromise));\r\n    return _anySyncCreator.v(values, timeout);\r\n}","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { ICachedValue, isUndefined } from \"@nevware21/ts-utils\";\r\nimport { _createAllPromise, _createAllSettledPromise, _createAnyPromise, _createPromise, _createRacePromise, _createRejectedPromise, _createResolvedPromise } from \"./base\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { idleItemProcessor } from \"./itemProcessor\";\r\nimport { PromiseExecutor } from \"../interfaces/types\";\r\nimport { IPromiseResult } from \"../interfaces/IPromiseResult\";\r\nimport { _pureAssign } from \"../internal/treeshake_helpers\";\r\n\r\nlet _defaultIdleTimeout: number | undefined;\r\n\r\nlet _allIdleSettledCreator: ICachedValue<<T extends readonly unknown[] | []>(input: T, timeout?: number) => IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }>>;\r\nlet _raceIdleCreator: ICachedValue<<T extends readonly unknown[] | []>(values: T, timeout?: number) => IPromise<Awaited<T[number]>>>;\r\nlet _anyIdleCreator: ICachedValue<<T extends readonly unknown[] | []>(values: T, timeout?: number) => IPromise<Awaited<T[number]>>>;\r\n\r\n/**\r\n * Sets the global default idle timeout / deadline to use when no timeout is passed during promise creation.\r\n * @param idleDeadline - Specifies the time in milliseconds to use as the idle timeout / deadline by when any\r\n * outstanding chained items should be executed.\r\n * @group Idle\r\n */\r\nexport function setDefaultIdlePromiseTimeout(idleDeadline?: number | undefined) {\r\n    _defaultIdleTimeout = idleDeadline;\r\n}\r\n\r\n/**\r\n * @deprecated Use `setDefaultIdlePromiseTimeout` instead\r\n * Sets the global default idle timeout / deadline to use when no timeout is passed during promise creation.\r\n * @param idleDeadline - Specifies the time in milliseconds to use as the idle timeout / deadline by when any\r\n * outstanding chained items should be executed.\r\n * @group Idle\r\n */\r\nexport const setDefaultIdleTimeout = (/*#__PURE__*/_pureAssign(setDefaultIdlePromiseTimeout));\r\n\r\n/**\r\n * Creates an idle Promise instance that when resolved or rejected will execute it's pending chained operations\r\n * __asynchronously__ using the `requestIdleCallback` API (if available) with the optional provided timeout value to\r\n * schedule when the chained items will be executed. When `requestIdleCallback` is not available this becomes the same as\r\n * `createAsyncPromise` which uses `setTimeout` to schedule executions.\r\n * @group Idle\r\n * @group Promise\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n * @param timeout - Optional deadline timeout to wait before processing the items, defaults to undefined. If the number of\r\n * milliseconds represented by this parameter has elapsed and the callback has not already been called, then a task to execute\r\n * the callback is queued in the event loop (even if doing so risks causing a negative performance impact). timeout must be a\r\n * positive value or it is ignored.\r\n */\r\nexport function createIdlePromise<T>(executor: PromiseExecutor<T>, timeout?: number): IPromise<T>  {\r\n    let theTimeout = isUndefined(timeout) ? _defaultIdleTimeout : timeout;\r\n    return _createPromise(createIdlePromise, idleItemProcessor(theTimeout), executor, theTimeout);\r\n}\r\n\r\n/**\r\n * Returns an idle Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __asynchronously__\r\n * using the `requestIdleCallback` API (if available) with the optional provided timeout value to\r\n * schedule when the chained items will be executed.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * When resolved or rejected any additional chained operations will execute __asynchronously__ using\r\n * the `requestIdleCallback` API (if available) with the optional provided timeout value to schedule\r\n * when the chained items will be executed. (eg. `then()`; `catch()`; `finally()`).\r\n * @group Idle\r\n * @group Promise\r\n * @group All\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional deadline timeout to wait before processing the items, defaults to undefined. If the number of\r\n * milliseconds represented by this parameter has elapsed and the callback has not already been called, then a task to execute\r\n * the callback is queued in the event loop (even if doing so risks causing a negative performance impact). timeout must be a\r\n * positive value or it is ignored.\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport const createIdleAllPromise: <T>(input: Iterable<PromiseLike<T>>, timeout?: number) => IPromise<T[]> = /*#__PURE__*/_createAllPromise(createIdlePromise);\r\n\r\n/**\r\n * Returns an idle Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __asynchronously__ using the\r\n * `requestIdleCallback` API (if available) with the optional provided timeout value to schedule when\r\n * the chained items will be executed. (eg. `then()`; `finally()`).\r\n * @group Idle\r\n * @group Promise\r\n * @group Resolved\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport const createIdleResolvedPromise: <T>(value: T, timeout?: number) => IPromise<T> = /*#__PURE__*/_createResolvedPromise(createIdlePromise);\r\n\r\n/**\r\n * Returns an idle Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __asynchronously__ using the o`requestIdleCallback` API\r\n * (if available) with the optional provided timeout value to schedule when the chained items will\r\n * be executed. (eg. `catch()`; `finally()`).\r\n * @group Idle\r\n * @group Promise\r\n * @group Rejected\r\n * @param reason - The rejection reason\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport const createIdleRejectedPromise: <T = unknown>(reason: any, timeout?: number) => IPromise<T> = /*#__PURE__*/_createRejectedPromise(createIdlePromise);\r\n\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the\r\n * {@link createIdlePromise | idle} promise implementation. Any chained operations will execute\r\n * __asynchronously__ when the environment is idle as the final operation pending promises have resolved,\r\n * or if the input contains no promises. It will resolve only after all of the input promises have either\r\n * resolved or rejected, and will resolve with an array of {@link IPromiseResult } objects that each describe\r\n * the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Idle\r\n * @group Promise\r\n * @group AllSettled\r\n * @param values - The iterator of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createIdleAllSettledPromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<IPromiseResult<Awaited<T>>[]>;\r\n\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the\r\n * {@link createIdlePromise | idle} promise implementation. Any chained operations will execute\r\n * __asynchronously__ when the environment is idle as the final operation pending promises have resolved,\r\n * or if the input contains no promises. It will resolve only after all of the input promises have either\r\n * resolved or rejected, and will resolve with an array of {@link IPromiseResult } objects that each describe\r\n * the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Idle\r\n * @group Promise\r\n * @group AllSettled\r\n * @param input - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createIdleAllSettledPromise<T extends readonly unknown[] | []>(input: T, timeout?: number): IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }> {\r\n    !_allIdleSettledCreator && (_allIdleSettledCreator = _createAllSettledPromise(createIdlePromise));\r\n    return _allIdleSettledCreator.v(input, timeout);\r\n}\r\n\r\n/**\r\n * The `createIdleRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createIdleRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Idle\r\n * @group Promise\r\n * @group Race\r\n * @param values - An iterable object of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * asynchronously when the system detects that the runtime is idle.\r\n */\r\nexport function createIdleRacePromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n\r\n/**\r\n * The `createIdleRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createIdleRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Idle\r\n * @group Promise\r\n * @group Race\r\n * @param values - An the array of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * asynchronously when the system detects that the runtime is idle.\r\n */\r\nexport function createIdleRacePromise<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>> {\r\n    !_raceIdleCreator && (_raceIdleCreator = _createRacePromise(createIdlePromise));\r\n    return _raceIdleCreator.v(values, timeout);\r\n}\r\n\r\n/**\r\n * The `createIdleAnyPromise` method takes an iterable of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Idle\r\n * @group Promise\r\n * @group Any\r\n * @param values - An iterable object of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createIdleAnyPromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n        \r\n/**\r\n * The `createIdleAnyPromise` method takes an array of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Idle\r\n * @group Promise\r\n * @group Any\r\n * @param values - An Array promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createIdleAnyPromise<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>> {\r\n    !_anyIdleCreator && (_anyIdleCreator = _createAnyPromise(createIdlePromise));\r\n    return _anyIdleCreator.v(values, timeout);\r\n}","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { createCachedValue, ICachedValue } from \"@nevware21/ts-utils\";\r\nimport { _createAllPromise, _createAllSettledPromise, _createAnyPromise, _createRacePromise, _createRejectedPromise, _createResolvedPromise } from \"./base\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { createNativePromise } from \"./nativePromise\";\r\nimport { PromiseExecutor } from \"../interfaces/types\";\r\nimport { IPromiseResult } from \"../interfaces/IPromiseResult\";\r\n\r\nlet _promiseCreator: ICachedValue<<T>(executor: PromiseExecutor<T>, timeout?: number) => IPromise<T>>;\r\nlet _allSettledCreator: ICachedValue<<T extends readonly unknown[] | []>(input: T, timeout?: number) => IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }>>;\r\nlet _raceCreator: ICachedValue<<T extends readonly unknown[] | []>(values: T, timeout?: number) => IPromise<Awaited<T[number]>>>;\r\nlet _anyCreator: ICachedValue<<T extends readonly unknown[] | []>(values: T, timeout?: number) => IPromise<Awaited<T[number]>>>;\r\n\r\n/**\r\n * Set the default promise implementation to use when calling `createPromise`; `createAllPromise`; `createResolvedPromise`\r\n * and `createRejectedPromise`. This is effective a global value and changing this will affect ALL callers of these\r\n * functions, as such these functions should only be used when switching implementations would have not unexpected\r\n * consequences like switching from a `createSyncPromise` to `createIdlePromise` where idle promises have a possibility\r\n * of never getting called during application shutdown or during an expected timeframe.\r\n * @group Alias\r\n * @group Promise\r\n * @param creator - The creator function to call when a new promise is required.\r\n */\r\nexport function setCreatePromiseImpl(\r\n    creator: <T>(executor: PromiseExecutor<T>, timeout?: number) => IPromise<T>\r\n) {\r\n    _promiseCreator = creator ? createCachedValue(creator) : null;\r\n}\r\n\r\n/**\r\n * Creates a Promise instance using the current default promise creator that when resolved or rejected will execute\r\n * it's pending chained operations.\r\n * @group Alias\r\n * @group Promise\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n * @param timeout - [Optional] timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport function createPromise<T>(executor: PromiseExecutor<T>, timeout?: number): IPromise<T>  {\r\n    !_promiseCreator && (_promiseCreator = createCachedValue(createNativePromise));\r\n\r\n    return _promiseCreator.v.call(this, executor, timeout);\r\n}\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __asynchronously__ using the optional\r\n * provided timeout value to schedule when the chained items will be executed, or if the input contains no promises.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * If the runtime doesn't support the Promise.all it will fallback back to an asynchronous Promise implementation.\r\n * @group Alias\r\n * @group Promise\r\n * @group All\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport const createAllPromise: <T>(input: Iterable<PromiseLike<T>>, timeout?: number) => IPromise<T[]> = /*#__PURE__*/_createAllPromise(createPromise);\r\n\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __asynchronously__ using the optional\r\n * timeout value to schedule when the chained items will be executed.(eg. `then()`; `finally()`).\r\n * @group Alias\r\n * @group Promise\r\n * @group Resolved\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport const createResolvedPromise: <T>(value: T, timeout?: number) => IPromise<T> = /*#__PURE__*/_createResolvedPromise(createPromise);\r\n\r\n/**\r\n * Returns a single asynchronous Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __asynchronously__ using the optional timeout value to schedule\r\n * when then chained items will be executed. (eg. `catch()`; `finally()`).\r\n * @group Alias\r\n * @group Promise\r\n * @group Rejected\r\n * @param reason - The rejection reason\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport const createRejectedPromise: <T = unknown>(reason: any, timeout?: number) => IPromise<T> = /*#__PURE__*/_createRejectedPromise(createPromise);\r\n\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the current\r\n * promise implementation. If the current implementation is synchronous then the chained operations will\r\n * execute __synchronously__ in the same execution cycle as the final operation pending promises have resolved,\r\n * or if the input contains no promises. If the current implementation is asynchronous then the chained\r\n * operations will execute __asynchronously__ using the optional provided timeout value to schedule when the\r\n * chained items will be executed or if the input contains no promises.\r\n * It will resolve only after all of the input promises have either resolved or rejected, and will resolve with an array\r\n * of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group AllSettled\r\n * @param values - The iterator of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createAllSettledPromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<IPromiseResult<Awaited<T>>[]>;\r\n\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the current\r\n * promise implementation. If the current implementation is synchronous then the chained operations will\r\n * execute __synchronously__ in the same execution cycle as the final operation pending promises have resolved,\r\n * or if the input contains no promises. If the current implementation is asynchronous then the chained\r\n * operations will execute __asynchronously__ using the optional provided timeout value to schedule when the\r\n * chained items will be executed or if the input contains no promises.\r\n * It will resolve only after all of the input promises have either resolved or rejected, and will resolve with an array\r\n * of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group AllSettled\r\n * @param input - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createAllSettledPromise<T extends readonly unknown[] | []>(input: T, timeout?: number): IPromise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }> {\r\n    !_allSettledCreator && (_allSettledCreator = _createAllSettledPromise(createPromise));\r\n    return _allSettledCreator.v(input, timeout);\r\n}\r\n\r\n/**\r\n * The `createRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Race\r\n * @param values - An iterable object of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * based on the current promise implementation.\r\n */\r\nexport function createRacePromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n\r\n/**\r\n * The `createRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Race\r\n * @param values - An the array of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * based on the current promise implementation.\r\n */\r\nexport function  createRacePromise<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>> {\r\n    !_raceCreator && (_raceCreator = _createRacePromise(createPromise));\r\n    return _raceCreator.v(values, timeout);\r\n}\r\n\r\n/**\r\n * The `createAnyPromise` method takes an iterable of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Any\r\n * @param values - An iterable object of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createAnyPromise<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n        \r\n/**\r\n * The `createAnyPromise` method takes an array of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Any\r\n * @param values - An Array promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createAnyPromise<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>> {\r\n    !_anyCreator && (_anyCreator = _createAnyPromise(createPromise));\r\n    return _anyCreator.v(values, timeout);\r\n}","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2024 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { isUndefined, scheduleTimeout } from \"@nevware21/ts-utils\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { createPromise } from \"./promise\";\r\n\r\n/**\r\n * Creates a Promise instance that resolve or reject after the specified timeout.\r\n * @since 0.5.0\r\n * @group Timeout\r\n * @group Promise\r\n * @param timeout - The timeout in milliseconds to wait before resolving or rejecting the promise.\r\n * @param resolveReject - [Optional] If true the promise will resolve, otherwise it will reject.\r\n * @param message - [Optional] The message to use when rejecting the promise, if not supplied (or\r\n * undefined) the default message will be used.\r\n * @returns A promise that will resolve or reject after the specified timeout.\r\n * @example\r\n * ```ts\r\n * // Rejects after 100ms with default message\r\n * const result = await createTimeoutPromise(100);\r\n * // Throws an Error: Timeout of 100ms exceeded\r\n *\r\n * // Resolves after 100ms with default message\r\n * const result = await createTimeoutPromise(100, true);\r\n * console.log(result); // Timeout of 100ms exceeded\r\n *\r\n * // Rejects after 100ms with default message\r\n * const result = await createTimeoutPromise(100, false);\r\n * // throws an Error: Timeout of 100ms exceeded\r\n *\r\n * // Resolves after 100ms with default message\r\n * const result = await createTimeoutPromise(100, true);\r\n * console.log(result); // Timeout of 100ms exceeded\r\n *\r\n * // Rejects after 100ms with the message \"Hello\"\r\n * const result = await createTimeoutPromise(100, false, \"Hello\");\r\n * // throws an Error: Hello\r\n *\r\n * // Resolves after 100ms with the message \"Hello\"\r\n * const result = await createTimeoutPromise(100, true, \"Hello\");\r\n * console.log(result); // Hello\r\n *\r\n * // Resolves after 100ms with the message \"Hello\"\r\n * doAwait(createTimeoutPromise(100, true, \"Hello\"), (result) => {\r\n *  console.log(result); // Hello\r\n * });\r\n *\r\n * // Rejects after 100ms with the message \"Hello\"\r\n * doAwait(createTimeoutPromise(100, false, \"Hello\"), (result) => {\r\n *   // Not called\r\n * }, (err) => {\r\n *   console.log(err); // Hello\r\n * });\r\n *\r\n * // Rejects after 100ms with the message \"Hello\"\r\n * doAwaitResult(createTimeoutPromise(100, false, \"Hello\"), (result) => {\r\n *   console.log(result.rejected); // true\r\n *   console.log(result.reason); // Hello\r\n * });\r\n * ```\r\n */\r\nexport function createTimeoutPromise<T = any>(timeout: number, resolveReject?: boolean, message?: T): IPromise<T> {\r\n    return createPromise((resolve, reject) => {\r\n        scheduleTimeout(() => {\r\n            (resolveReject ? resolve : reject)(!isUndefined(message) ? message : \"Timeout of \" + timeout + \"ms exceeded\" as T);\r\n        }, timeout);\r\n    });\r\n}\r\n","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2023 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { isFunction, isPromiseLike, utcNow } from \"@nevware21/ts-utils\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { createPromise } from \"../promise/promise\";\r\nimport { doAwait } from \"../promise/await\";\r\nimport { RejectPromiseHandler, ResolvePromiseHandler } from \"../interfaces/types\";\r\nimport { IWhileState } from \"../interfaces/IWhileState\";\r\n\r\nfunction _doneChk<T>(isDone: boolean, state: IWhileState<T>, value: T, thisArg?: any) {\r\n    let result: boolean | IPromise<boolean> = isDone;\r\n    state.res = value;\r\n    if (!result) {\r\n        if (state.isDone && isFunction(state.isDone)) {\r\n            // Handle synchronous or asynchronous isDone function\r\n            return doAwait(state.isDone.call(thisArg, state), (done) => {\r\n                state.iter++;\r\n                return !!done;\r\n            });\r\n        } else {\r\n            result = !!state.isDone;\r\n        }\r\n    }\r\n\r\n    state.iter++;\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Performs a while loop, calling the provided `callbackFn` function until the `state.isDone`\r\n * property is set to `true` or the optional `isDOneFn` returns `true`. The callback function will\r\n * receive a single {@link IWhileState | state} argument and may return either a value or a promise,\r\n * if a promise is returned the while loop will wait until the promise is resolved before calling\r\n * the callback function again. If the callback function never returns a promise the while loop\r\n * will be executed synchronous and last value returned by the callback will be returned, if the\r\n * callback function returns a promise the while loop will be asynchronous and an {@link IPromise}\r\n * will be returned and resolved with the last value returned by the callback or rejected if the\r\n * callback promise rejects or throws an error.\r\n * @since 0.5.0\r\n * @group Loop\r\n * @typeParam T - Identifies the element type returned by the callback function.\r\n * @param callbackFn - A function that will be called until the `state.isDone` flag is set to `true`\r\n * the function will receive a single {@link IWhileState | state} argument. The callback function\r\n * may return either a value or a promise, if a promise is returned the while loop will wait\r\n * until the promise is resolved before calling the callback function again.\r\n * @param isDoneFn - An optional function that will be called after the callback function is called,\r\n * that can be used to stop the while loop. The function will receive a single {@link IWhileState | state}\r\n * argument. If the function returns `true` the while loop will stop, otherwise the while loop will continue.\r\n * @param thisArg - An object to which the this keyword can refer in the callbackfn function.\r\n * If thisArg is omitted, null or undefined the array will be used as the this value.\r\n * @remarks\r\n * - If an `isDoneFn` is provided the `state.isDone` property will be set to the provided value and\r\n * is accessible withing the callback function. The callbackFn may overwrite the value of the\r\n * `state.isDone` property within the callback function with a boolean value or another function that\r\n * returns a boolean value.\r\n * - The callback function is called until until the `state.isDone` property is set to `true` or if\r\n * `state.isDone` is a function until the function returns `true`.\r\n * - The callback function will receive a single {@link IWhileState | state} argument that contains\r\n * the following properties:\r\n *  - `iter` - The zero-based iteration count, which is incremented after each call to the `callbackFn`\r\n * and any `isDone` function (if provided), the `iter` property is accessible withing the callback\r\n * function and may be overwritten within the callback function.\r\n * - `res` - The last resolved result value returned by the `callbackFn` function.\r\n * - `isDone` - A boolean value or a callback function that will be called to check if the while loop\r\n * should stop, the `isDone` property is accessible withing the callback function and may be\r\n * overwritten within the callback function.\r\n * - The callback function may return either a value or a promise, if a promise is returned the while\r\n * loop will wait until the promise is resolved before calling the callback function again.\r\n * - If the callback function throws an error when executing `synchronously` the exception will\r\n * also be thrown `synchronously` otherwise the returned promise will be rejected with the error.\r\n * @example\r\n * ```ts\r\n * // Synchronous example\r\n * const result = doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *    if (state.idx < 10) {\r\n *      // Logs each iteration index (will be called synchronously)\r\n *      // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *      console.log(state.idx);\r\n *   } else {\r\n *     state.isDone = true;\r\n *     return \"Hello\";\r\n *  }\r\n * });\r\n *\r\n * console.log(result); // returns Hello after logging 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *\r\n * // Synchronous example with isDoneFn\r\n * const result = doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *    if (state.idx < 10) {\r\n *      // Logs each iteration index (will be called synchronously)\r\n *      // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *      console.log(state.idx);\r\n *   } else {\r\n *     return \"Hello\";\r\n *  }\r\n * }, (state) => state.idx > 10);\r\n * console.log(result); // returns Hello after logging 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *\r\n * // Asynchronous examples\r\n * const result = await doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *   if (state.idx < 10) {\r\n *     // Logs each iteration index\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 calling the callback function synchronously\r\n *     console.log(state.idx);\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before calling the callback function again.\r\n *     return createTimeoutPromise(10, true, state.idx);\r\n *   }\r\n *\r\n *   state.isDone = true;\r\n *   return createResolvedPromise(\"Darkness\");\r\n * });\r\n * console.log(result); // Darkness\r\n *\r\n * // Asynchronous example with isDoneFn\r\n * const result = await doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *   if (state.idx < 10) {\r\n *     // Logs each iteration index\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 calling the callback function synchronously\r\n *     console.log(state.idx);\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before calling the callback function again.\r\n *     return createTimeoutPromise(10, true, state.idx);\r\n *   }\r\n *\r\n *   return createResolvedPromise(\"Darkness\");\r\n * }, (state) => state.idx > 10);\r\n * console.log(result); // returns Darkness after logging 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *\r\n * // Combination Synchronous and Asynchronous example\r\n * const result = await doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *   if (state.idx < 10) {\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *     // Logs each iteration index (will be called synchronously)\r\n *     console.log(state.idx);\r\n *   } else {\r\n *     state.isDone = true;\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before resolving the returned promise.\r\n *     return createResolvedPromise(\"my old friend\");\r\n *   }\r\n * });\r\n *\r\n * console.log(result); // my old friend\r\n *\r\n * // Asynchronous example using await\r\n * const result = await doWhileAsync(async (state) => {\r\n *   if (state.idx < 10) {\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *     // Logs each iteration index (will be called synchronously)\r\n *     await createTimeoutPromise(10, true, state.idx);\r\n *   } else {\r\n *     state.isDone = true;\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before resolving the returned promise.\r\n *     return await createResolvedPromise(\"my old friend\");\r\n *   }\r\n * });\r\n *\r\n * console.log(result); // my old friend\r\n *\r\n * // Asynchronous example using await and dynamically setting the isDone function\r\n * const result = await doWhileAsync(async (state) => {\r\n *   // dynamically set the isDone function\r\n *   if (state.idx < 10) {\r\n *     state.isDone = () => return false;\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *     // Logs each iteration index (will be called synchronously)\r\n *     await createTimeoutPromise(10, true, state.idx);\r\n *   } else {\r\n *     state.isDone = () => return true;\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before resolving the returned promise.\r\n *     return await createResolvedPromise(\"my old friend\");\r\n *   }\r\n * });\r\n *\r\n * console.log(result); // my old friend\r\n * ```\r\n */\r\nexport function doWhileAsync<T>(callbackFn: (state: IWhileState<T>) => T | IPromise<T>, isDoneFn?: (state: IWhileState<T>) => boolean | void | IPromise<boolean | void>, thisArg?: any): T | IPromise<T> {\r\n    let promise: T | IPromise<T>;\r\n    let resolve: ResolvePromiseHandler<T>;\r\n    let reject: RejectPromiseHandler | never = (reason: any) => {\r\n        isDone = true;\r\n        throw reason;\r\n    };\r\n    let isDone = false;\r\n    let state: IWhileState<T> = {\r\n        st: utcNow(),\r\n        iter: 0,\r\n        isDone: isDoneFn || false\r\n    };\r\n\r\n    if (callbackFn) {\r\n        const _createPromise = (): IPromise<T> => {\r\n            return createPromise<T>((res, rej) => {\r\n                resolve = res;\r\n                reject = rej;\r\n            });\r\n        };\r\n\r\n        const _handleAsyncDone = (done: boolean) => {\r\n            isDone = !!done;\r\n            if (!isDone) {\r\n                _processNext();\r\n            } else {\r\n                resolve(state.res);\r\n            }\r\n        };\r\n\r\n        const _processNext = (): T | IPromise<T> => {\r\n            // Attempt to process the next item synchronously if possible (for performance -- to reduce the number of promises created)\r\n            while (!isDone) {\r\n                try {\r\n                    let cbResult = callbackFn.call(thisArg, state);\r\n                    if (isPromiseLike(cbResult)) {\r\n                        promise = promise || _createPromise();\r\n                        doAwait(cbResult, (res) => {\r\n                            try {\r\n                                doAwait(_doneChk(isDone, state, res, thisArg), _handleAsyncDone, reject);\r\n                            } catch (e) {\r\n                                reject(e);\r\n                            }\r\n                        }, reject);\r\n\r\n                        // Break out of synchronous loop and wait for promise to resolve\r\n                        return promise;\r\n                    } else {\r\n                        let dnRes = _doneChk(isDone, state, cbResult, thisArg);\r\n                        if (isPromiseLike(dnRes)) {\r\n                            promise = promise || _createPromise();\r\n                            doAwait(dnRes, _handleAsyncDone, reject);\r\n\r\n                            // Break out of synchronous loop and wait for promise to resolve\r\n                            return promise;\r\n                        } else {\r\n                            isDone = !!dnRes;\r\n                        }\r\n                    }\r\n                } catch (e) {\r\n                    reject(e);\r\n                    return promise;\r\n                }\r\n            }\r\n            \r\n            if (isDone && resolve) {\r\n                resolve(state.res);\r\n            }\r\n\r\n            return promise || state.res;\r\n        };\r\n    \r\n        return _processNext();\r\n    }\r\n}","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2023 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { getLength } from \"@nevware21/ts-utils\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { doWhileAsync } from \"./doWhileAsync\";\r\nimport { IWhileState } from \"../interfaces/IWhileState\";\r\n\r\n/**\r\n * Calls the provided `callbackFn` function once for each element in an array (or ArratLike) instance in ascending index order. It is not invoked\r\n * for index properties that have been deleted or are uninitialized. And unlike the ES6 forEach() this supports async functions and you CAN stop\r\n * or break the iteration  by returning -1 from the `callbackFn` function.\r\n *\r\n * The range (number of elements) processed by arrForEach() is set before the first call to the `callbackFn`. Any elements added beyond the range\r\n * or elements which as assigned to indexes already processed will not be visited by the `callbackFn`.\r\n *\r\n * The `callbackFn` may execute `synchronously` or `asynchronously` and if the `callbackFn` returns a `Promise` then the next iteration will not be\r\n * called until the promise is resolved. If the `callbackFn` returns a `Promise` that is rejected then the iteration will stop and the promise\r\n * returned by arrForEachAsync will be rejected with the same error.\r\n * @since 0.5.0\r\n * @group Loop\r\n * @group Array\r\n * @group ArrayLike\r\n * @typeParam T - Identifies the element type of the array\r\n * @param theArray - The array or array like object of elements to be searched.\r\n * @param callbackFn - A `asynchronous` or `synchronous` function that accepts up to three arguments. arrForEach calls the callbackfn function one\r\n * time for each element in the array.\r\n * @param thisArg - An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, null or undefined\r\n * the array will be used as the this value.\r\n * @remarks\r\n * arrForEachAsync supports either a `synchronous` or `asynchronous` (returns a `Promise`) callback function. If the callback function returns\r\n * a `Promise` then the next iteration will not be called until the promise is resolved. If the callback function returns a `Promise` that is\r\n * rejected then the iteration will stop and the promise returned by arrForEachAsync will be rejected with the same error.\r\n * @example\r\n * ```ts\r\n * const items = ['item1', 'item2', 'item3', 'item4', 'item5', 'item6', 'item7', 'item8', 'item9', 'item10'];\r\n * const copyItems = [];\r\n *\r\n * arrForEachASync(items, (value, index) => {\r\n *   copyItems.push(value);\r\n *   if (index === 5) {\r\n *     return -1; // Stop the iteration\r\n *   }\r\n * });\r\n * console.log(copyItems); // ['item1', 'item2', 'item3', 'item4', item5']\r\n *\r\n * // Also supports input as an array like object\r\n * const items = { length: 3, 0: 'item1', 1: 'item2', 2: 'item3' };\r\n *\r\n * // Asynchronous examples using await\r\n * const items = ['item1', 'item2', 'item3', 'item4', 'item5', 'item6', 'item7', 'item8', 'item9', 'item10'];\r\n * const copyItems = [];\r\n *\r\n * await arrForEachASync(items, (value, index) => { // Note: DO NOT use async here unless you use await within the function\r\n *   if (index < 5) {\r\n *     // Logs each iteration index\r\n *     // Logs each value\r\n *     console.log(value);\r\n *     // Returning a promise will cause `arrForEachAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before calling the callback function again.\r\n *     return createTimeoutPromise(10, true);\r\n *   }\r\n *\r\n *   return -1; // Stop the iteration\r\n * });\r\n * console.log(copyItems); // ['item1', 'item2', 'item3', 'item4', item5']\r\n *\r\n * ```\r\n */\r\nexport function arrForEachAsync<T = any>(theArray: ArrayLike<T>, callbackFn: (value: T, index: number, array: T[]) => void | number | IPromise<void | number>, thisArg?: any): void | number | IPromise<void | number> {\r\n    if (theArray) {\r\n        const len = getLength(theArray);\r\n        if (len) {\r\n            const isDone = (state: IWhileState<void | number>) => {\r\n                if (state.iter >= len || state.res === -1) {\r\n                    return true;\r\n                }\r\n            };\r\n\r\n            return doWhileAsync((state) => {\r\n                const idx = state.iter;\r\n                if (idx in theArray) {\r\n                    return callbackFn.call(thisArg || theArray, theArray[idx], idx, theArray);\r\n                }\r\n            }, isDone);\r\n        }\r\n    }\r\n}","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2023 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { ICachedValue, WellKnownSymbols, createCachedValue, fnCall, getKnownSymbol, isIterator, isPromiseLike } from \"@nevware21/ts-utils\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { doWhileAsync } from \"./doWhileAsync\";\r\nimport { IWhileState } from \"../interfaces/IWhileState\";\r\nimport { DONE, RETURN, VALUE } from \"../internal/constants\";\r\nimport { doAwait, doFinally } from \"../promise/await\";\r\n\r\nlet _iterSymbol: ICachedValue<symbol>;\r\nlet _iterAsyncSymbol: ICachedValue<symbol>;\r\n\r\n/**\r\n * Calls the provided `callbackFn` function once for each element in the iterator or iterator returned by\r\n * the iterable and processed in the same order as returned by the iterator. As with the {@link arrForEachAsync}\r\n * you CAN stop or break the iteration by returning -1 from the `callbackFn` function.\r\n *\r\n * The order of processing is not reset if you add or remove elemenets to the iterator, the actual behavior will\r\n * depend on the iterator implementation.\r\n *\r\n * if the passed `iter` is both an Iterable\\<T\\> and Iterator\\<T\\> the Iterator\\<T\\> interface takes precedence. And if\r\n * an iterable and does not have a `Symbol.iterator` property then the `iter` will be used as the iterator.\r\n *\r\n * The `callbackFn` may execute `synchronously` or `asynchronously` and if the `callbackFn` returns a `Promise`\r\n * then the next iteration will not be called until the promise is resolved. If the `callbackFn` returns a `Promise`\r\n * that is rejected then the iteration will stop and the promise returned by iterForEachAsync will be rejected with\r\n * the same error.\r\n * @remarks\r\n * If Symbols are NOT supported then the iterable MUST be using the same polyFill for the well know symbols, as used\r\n * by the library. If the iterable is using a different polyFill then the `iter` MUST be an Iterator\\<T\\> and not an\r\n * Iterable\\<T\\>.\r\n * If you are targetting a mixed environment you SHOULD either\r\n * - only use the polyfill Symbol's provided by this library\r\n * - ensure that you add any symbol polyfills BEFORE these utilities\r\n * iterForOfAsync\r\n * @since 0.5.0\r\n * @group Loop\r\n * @group Iterator\r\n * @typeParam T - Identifies the element type of the iterator\r\n * @param iter - The iterator or iterable of elements to be searched.\r\n * @param callbackFn - A `asynchronous` or `synchronous` function that accepts up to three arguments. iterForEach\r\n * calls the callbackfn function one time for each element in the iterator.\r\n * @param thisArg - An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted,\r\n * null or undefined the iterator will be used as the this value.\r\n * @example\r\n * ```ts\r\n * const items = ['item1', 'item2', 'item3', 'item4', 'item5', 'item6', 'item7', 'item8', 'item9', 'item10'];\r\n * const copyItems = [];\r\n *\r\n * // using async / await\r\n * let result = await iterForOfAsync(items, async (value, index) => {\r\n *   copyItems.push(value);\r\n *   if (index === 5) {\r\n *     return -1; // Stop the iteration\r\n *   }\r\n *\r\n *   await createTimeoutPromise(100); // Wait 100ms before processing the next item, you could also just return the promise\r\n *  })\r\n *\r\n * console.log(result); // returns -1 if the loop was stopped, otherwise returns undefined\r\n *\r\n * // using doAwait\r\n * doAwait(iterForOfAsync(items, (value, index) => {\r\n *   copyItems.push(value);\r\n *   if (index === 5) {\r\n *     return -1; // Stop the iteration\r\n *   }\r\n *\r\n *   return createTimeoutPromise(100); // Wait 100ms before processing the next item, you could also just return the promise\r\n *  }), (result) => {\r\n *    console.log(result); // returns -1 if the loop was stopped, otherwise returns undefined\r\n *  });\r\n * ```\r\n */\r\nexport function iterForOfAsync<T = any>(iter: Iterator<T> | Iterable<T> | AsyncIterator<T> | AsyncIterable<T>, callbackFn: (value: T, count: number, iter?: Iterator<T> | AsyncIterator<T>) => void | number | IPromise<void | number>, thisArg?: any): void | number | IPromise<void | number> {\r\n    let err: { e: any };\r\n    let iterResult: IteratorResult<T>;\r\n    let theIter: AsyncIterator<T> | Iterator<T> = iter as AsyncIterator<T> | Iterator<T>;\r\n\r\n    function onFailed(failed: any): never  {\r\n        err = { e: failed };\r\n        if (theIter.throw) {\r\n            iterResult = null;\r\n            theIter.throw(err);\r\n        }\r\n\r\n        throw failed;\r\n    }\r\n\r\n    function onFinally() {\r\n        try {\r\n            if (iterResult && !iterResult[DONE]) {\r\n                theIter[RETURN] && theIter[RETURN](iterResult);\r\n            }\r\n        } finally {\r\n            if (err) {\r\n                // eslint-disable-next-line no-unsafe-finally\r\n                throw err.e;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (iter) {\r\n        if (!isIterator(iter)) {\r\n            // Get the asyncIterator from the iterable\r\n            !_iterAsyncSymbol && (_iterAsyncSymbol = createCachedValue(getKnownSymbol(WellKnownSymbols.asyncIterator)));\r\n            theIter = iter[_iterAsyncSymbol.v] ? iter[_iterAsyncSymbol.v]() : null;\r\n            if (!theIter) {\r\n                // Get the iterator from the iterable\r\n                !_iterSymbol && (_iterSymbol = createCachedValue(getKnownSymbol(WellKnownSymbols.iterator)));\r\n                theIter = iter[_iterSymbol.v] ? iter[_iterSymbol.v]() : null;\r\n            }\r\n        }\r\n        \r\n        if (theIter && isIterator(theIter)) {\r\n\r\n            let result: void | number | IPromise<void | number>;\r\n            try {\r\n                result = doWhileAsync((state) => {\r\n                    return doAwait(theIter.next(), (res) => {\r\n                        iterResult = res;\r\n                        if (!res[DONE]) {\r\n                            return fnCall(callbackFn, thisArg || theIter, iterResult[VALUE], state.iter, theIter);\r\n                        }\r\n                    }, (reason) => {\r\n                        state.isDone = true;\r\n                        onFailed(reason);\r\n                    });\r\n                }, (state: IWhileState<void | number>) => {\r\n                    if (!iterResult || iterResult[DONE] || state.res === -1) {\r\n                        onFinally();\r\n                        return true;\r\n                    }\r\n                }, thisArg || theIter);\r\n\r\n                if (isPromiseLike(result)) {\r\n                    result = doFinally(result.catch(onFailed), onFinally);\r\n                }\r\n\r\n                return result;\r\n            } catch (failed) {\r\n                onFailed(failed);\r\n            } finally {\r\n                if (result && !isPromiseLike(result)) {\r\n                    onFinally();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { arrForEach, arrIndexOf, createCustomError, CustomErrorConstructor, getLength, isPromiseLike, ITimerHandler, objDefine, objDefineProp, scheduleTimeout, utcNow } from \"@nevware21/ts-utils\";\r\nimport { doAwait, doAwaitResponse } from \"../promise/await\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { PromiseExecutor, RejectPromiseHandler, ResolvePromiseHandler,StartQueuedTaskFn } from \"../interfaces/types\";\r\nimport { ITaskDetail } from \"../internal/ITaskDetail\";\r\nimport { ITaskScheduler } from \"../interfaces/ITaskScheduler\";\r\nimport { createPromise } from \"../promise/promise\";\r\n\r\n//#ifdef DEBUG\r\n//#:(!DEBUG) import { _debugLog } from \"../promise/debug\";\r\n//#endif\r\n\r\nconst REJECT = \"reject\";\r\nconst REJECTED_ERROR = \"Rejected\";\r\n\r\nlet _schedulerId: number = 0;\r\nlet _debugName: any;\r\nlet _debugIntState: any;\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n */\r\nlet _customErrors: { [type: string]: CustomErrorConstructor } = {};\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal structure for report the debugging state\r\n */\r\ninterface _InternalDebugState {\r\n    l: ITaskDetail,\r\n    r: ITaskDetail[],\r\n    w: ITaskDetail[]\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Empty reject function to avoid trying to re-reject\r\n */\r\nfunction _rejectDone() {\r\n    // A Do nothing function\r\n}\r\n\r\nfunction _createError(type: string, evt: ITaskDetail, message?: string): Error {\r\n    // Lazily create the class\r\n    !_customErrors[type] && (_customErrors[type] = createCustomError(type));\r\n\r\n    let now = utcNow();\r\n    return new (_customErrors[type])(`Task [${evt.id}] ${message||\"\"}- ${(evt.st ? \"Running\" : \"Waiting\")}: ${_calcTime(now, evt.st || evt.cr)}`);\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal function used for displaying the time in milliseconds (during debugging)\r\n * @param now - The current time\r\n * @param start - The start time to subtract\r\n * @returns A string representation of the time difference\r\n */\r\nfunction _calcTime(now: number, start: number) {\r\n    return ((now - start) || \"0\") + \" ms\";\r\n}\r\n\r\n/**\r\n * Abort any stale tasks in the provided task Queue\r\n * @param taskQueue - The Task Queue to search\r\n * @param staleTimeoutPeriod - The maxumum stale timeout period\r\n */\r\nfunction _abortStaleTasks(taskQueue: ITaskDetail[], staleTimeoutPeriod: number): void {\r\n    let now = utcNow();\r\n    let expired = now - staleTimeoutPeriod;\r\n    arrForEach(taskQueue, (evt) => {\r\n        if (evt && !evt.rj && (evt.st && evt.st < expired) || (!evt.st && evt.cr && evt.cr < expired)) {\r\n            evt && evt[REJECT](evt.rj || _createError(\"Aborted\", evt, \"Stale \"));\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n * Remove the `taskDetail` from the `queue` if present\r\n * @param queue - The Task Queue\r\n * @param taskDetail - The Task detail to be removed\r\n */\r\nfunction _removeTask(queue: ITaskDetail[], taskDetail: ITaskDetail): void {\r\n    let idx = arrIndexOf(queue, taskDetail);\r\n    if (idx !== -1) {\r\n        queue.splice(idx, 1);\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore Internal function to add the debug state to the promise, this code is removed from the production artifacts\r\n * @param theScheduler - The scheduler instance to add the debug accessors to.\r\n * @param nameFn - The function to return then name of this scheduler\r\n * @param stateFn - The function to return the internal state of the scheduler\r\n */\r\nfunction _addDebugState(theScheduler: any, nameFn: () => string, stateFn: () => _InternalDebugState) {\r\n    _debugName = _debugName || { toString: () => \"[[SchedulerName]]\" };\r\n    _debugIntState = _debugIntState || { toString: () => \"[[SchedulerState]]\" };\r\n    \r\n    objDefineProp(theScheduler, _debugName, { get: nameFn });\r\n    objDefineProp(theScheduler, _debugIntState, { get: stateFn });\r\n}\r\n\r\n/**\r\n * Create a Task Scheduler using the optional promise implementation and scheduler name.\r\n * The newPromise can be any value promise creation function, where the execution of the\r\n * queued tasks will be processed based on how the promise implementation processes it's\r\n * chained promises (asynchrounsly; synchronously; idle processing, etc)\r\n *\r\n * The functions used to start each task my return a result (synchronous execution) or an\r\n * {@link IPromise}, `PromiseLike` or `Promise` result (asynchronous execution).\r\n *\r\n * Each task is executed in the order that it was queued and the provided `startTask` function\r\n * will not be called until all previous tasks have completed (whther they resolve or reject).\r\n * The result from any previous task does not affect and is not passed to any later scheduled\r\n * task, if you need this capability then your `startTask` functions will need to co-operate to\r\n * share any common context.\r\n *\r\n * By default, queued tasks which have either been \"waiting\" to run or have been running longer\r\n * then 10 minutes will be Auto-Rejected to try and free up resources. If a task is running when\r\n * it rejected then it will continue to \"run\" based on whatever operation it's `startTask` is\r\n * performing. If a task has not yet had it's `startTask` function called it will never get called.\r\n * In both cases the `IPromise` returned by the call to {@link ITaskScheduler.queue | queue} the\r\n * task will be `rejected`. You can change this default time, including disabling completly via\r\n * the {@link ITaskScheduler.setStaleTimeout | setStaleTimeout}\r\n * function.\r\n * @since 0.2.0\r\n * @group Scheduler\r\n * @param newPromise - The function to use for creating a new promise when required, if not\r\n * provided this will default to {@link createPromise} which will use the default registered\r\n * promise creation function which defaults to runtime native promises or async Promise if not\r\n * supported by the runtime.\r\n * @param name - The name you want to associated with this scheduler, mostly useful for debugging\r\n * @returns A new ITaskScheduler instance\r\n * @example\r\n * ```ts\r\n * let scheduler = createTaskScheduler();\r\n *\r\n * // Schedule a task using the ts-async helper promise functions\r\n * scheduler.queue(() => {\r\n *     return createPromise((resolve, reject) => {\r\n *         scheduleTimeout(() => {\r\n *             // Do something after a delay\r\n *         }, 100);\r\n *     });\r\n * });\r\n *\r\n * // Schedule an asynchronous task which uses async/await\r\n * scheduler.queue(async () => {\r\n *     // This task will only execute after the previous task has completed\r\n *     await performAnotherAsyncTask();\r\n * });\r\n *\r\n * // Schedule a synchronous task that executes and completes immediately\r\n * scheduled.queue(() => {\r\n *     // Do some synchronous task\r\n *     return 42;\r\n * });\r\n *\r\n * // Schedule an asynchronous task which returns a promise\r\n * scheduled.queue(() => {\r\n *     return doAwait(fetch(\"https://github.com/nevware21/ts-async/blob/main/README.md\"), (response) => {\r\n *         let theReadMe = response.text();\r\n *         // Do something with the readme\r\n *     });\r\n * });\r\n * ```\r\n */\r\nexport function createTaskScheduler(newPromise?: <T>(executor: PromiseExecutor<T>, timeout?: number) => IPromise<T>, name?: string): ITaskScheduler {\r\n    let _theTask: ITaskDetail;\r\n    let _running: ITaskDetail[] = [];\r\n    let _waiting: ITaskDetail[] = [];\r\n    let _staleTimeoutPeriod = 600000;            // 10 Minutes\r\n    let _staleTimeoutCheckPeriod = _staleTimeoutPeriod / 10;    // 1 Minute\r\n    let _taskCount = 0;\r\n    let _schedulerName = (name ? (name + \".\") : \"\") + _schedulerId++;\r\n    let _blockedTimer: ITimerHandler;\r\n\r\n    // Make sure that a promise creator has been assigned\r\n    newPromise = newPromise || createPromise;\r\n\r\n    const _startBlockedTimer = () => {\r\n        let hasTasks = (getLength(_running) + getLength(_waiting)) > 0;\r\n        if (_staleTimeoutPeriod > 0) {\r\n            if (!_blockedTimer) {\r\n                // Only attempt to drop stale / blocked tasks if the timeout period is defined\r\n                _blockedTimer = scheduleTimeout(() => {\r\n                    _abortStaleTasks(_running, _staleTimeoutPeriod);\r\n                    _abortStaleTasks(_waiting, _staleTimeoutPeriod);\r\n                    _blockedTimer && (_blockedTimer.enabled = ((getLength(_running) + getLength(_waiting)) > 0));\r\n                }, _staleTimeoutCheckPeriod);\r\n\r\n                _blockedTimer.unref();\r\n            }\r\n\r\n            _blockedTimer && (_blockedTimer.enabled = hasTasks);\r\n        } else {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_schedulerName, \"Stale Timer disabled\");\r\n            //#endif\r\n        }\r\n    }\r\n\r\n    const _queueTask = <T>(startAction: StartQueuedTaskFn<T>, taskName?: string, timeout?: number): IPromise<T> => {\r\n        let taskId: string = _schedulerName + \".\" + _taskCount++;\r\n        if (taskName) {\r\n            taskId += \"-(\" + taskName + \")\";\r\n        }\r\n       \r\n        let newTask: ITaskDetail = {\r\n            id: taskId,\r\n            cr: utcNow(),\r\n            to: timeout,\r\n            [REJECT]: (reason: any) => {\r\n                newTask.rj = reason || _createError(REJECTED_ERROR, newTask);\r\n                newTask[REJECT] = _rejectDone;\r\n            }\r\n        };\r\n\r\n        if (!_theTask) {\r\n            // We don't have any currently running task, so just start the next task\r\n            newTask.p = newPromise(_runTask(newTask, startAction));\r\n        } else {\r\n            // Start a new promise which will wait until all current active tasks are completed before starting\r\n            // the new task, it does not resolve this scheduled task until after the new task is resolve to\r\n            // ensure that all scheduled tasks are completed in the correct order\r\n            newTask.p = _waitForPreviousTask(newTask, _theTask, startAction);\r\n        }\r\n\r\n        // Set this new task as the last one, so that any future tasks will wait for this one\r\n        _theTask = newTask;\r\n\r\n        return newTask.p;\r\n    }\r\n\r\n    const _runTask = <T>(taskDetail: ITaskDetail, startAction: StartQueuedTaskFn<T>): PromiseExecutor<T> => {\r\n        taskDetail.st = utcNow();\r\n\r\n        // There should only ever be a single \"running\" task, but using an array\r\n        // for code reuse.\r\n        _running.push(taskDetail);\r\n        _startBlockedTimer();\r\n\r\n        // Create and return the promise executor for this action\r\n        return <T>(onTaskResolve: ResolvePromiseHandler<T>, onTaskReject: RejectPromiseHandler) => {\r\n            const _promiseReject = (reason: any) => {\r\n                taskDetail.rj = taskDetail.rj || reason || _createError(REJECTED_ERROR, taskDetail);\r\n                taskDetail[REJECT] = _rejectDone;\r\n                _doCleanup(taskDetail);\r\n                onTaskResolve = null;\r\n                onTaskReject && onTaskReject(reason);\r\n                onTaskReject = null;\r\n            }\r\n\r\n            let taskId = taskDetail.id;\r\n\r\n            if (taskDetail.rj) {\r\n                // Already aborted / pre-rejected\r\n                _promiseReject(taskDetail.rj);\r\n            } else {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_schedulerName, \"Task [\" + taskId + \"] Started after \" + _calcTime(taskDetail.st, taskDetail.cr));\r\n                //#endif\r\n                taskDetail[REJECT] = _promiseReject;\r\n\r\n                try {\r\n                    let startResult = startAction(taskId);\r\n                    if (taskDetail.to && isPromiseLike(startResult)) {\r\n                        taskDetail.t = scheduleTimeout(() => {\r\n                            _promiseReject(_createError(\"Timeout\", taskDetail));\r\n                        }, taskDetail.to);\r\n                    }\r\n\r\n                    doAwait(startResult, (theResult) => {\r\n                        _doCleanup(taskDetail);\r\n                        try {\r\n                            onTaskResolve && onTaskResolve(theResult as any);\r\n                        } catch (e) {\r\n                            onTaskReject && onTaskReject(e);\r\n                        }\r\n                        onTaskReject = null;\r\n                        onTaskResolve = null;\r\n                    }, _promiseReject);\r\n                } catch (e) {\r\n                    _promiseReject(e);\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    const _waitForPreviousTask = <T>(taskDetail: ITaskDetail, prevTask: ITaskDetail, startAction: StartQueuedTaskFn<T>): IPromise<T> => {\r\n        _waiting.push(taskDetail);\r\n        _startBlockedTimer();\r\n\r\n        return newPromise((onWaitResolve, onWaitReject) => {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) let taskId = taskDetail.id;\r\n            //#:(!DEBUG) let prevTaskId = prevTask.id;\r\n            //#:(!DEBUG) _debugLog(_schedulerName, \"[\" + taskId + \"] is waiting for [\" + prevTaskId + \"] to complete before starting -- [\" + _waiting.length + \"] waiting\");\r\n            //#endif\r\n\r\n            // Wait for the previous tasks to complete before starting this one.\r\n            // This ensures the queue execution order and avoids removing tasks that\r\n            // have not yet been started.\r\n            doAwaitResponse(prevTask.p, () => {\r\n                _removeTask(_waiting, taskDetail);\r\n                _runTask(taskDetail, startAction)(onWaitResolve, onWaitReject);\r\n            });\r\n        });\r\n    }\r\n\r\n    const _doCleanup = (taskDetail: ITaskDetail) => {\r\n        _removeTask(_running, taskDetail);\r\n\r\n        // If there was a timeout stop and clear\r\n        taskDetail.t && taskDetail.t.cancel();\r\n        taskDetail.t = null;\r\n\r\n        // Clear the matching current task now that it's complete\r\n        if (_theTask && _theTask === taskDetail) {\r\n            _theTask = null;\r\n            if (getLength(_running) + getLength(_waiting) === 0) {\r\n                _blockedTimer && _blockedTimer.cancel();\r\n                _blockedTimer = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    let theScheduler: ITaskScheduler =  {\r\n        idle: true,\r\n        queue: _queueTask,\r\n        setStaleTimeout: (staleTimeout: number, staleCheckPeriod?: number) => {\r\n            _blockedTimer && _blockedTimer.cancel();\r\n            _blockedTimer = null;\r\n            _staleTimeoutPeriod = staleTimeout;\r\n            _staleTimeoutCheckPeriod = staleCheckPeriod || staleTimeout / 10;\r\n            _startBlockedTimer();\r\n        }\r\n    };\r\n\r\n    // Change the idle property to dynamic\r\n    objDefine(theScheduler, \"idle\", {\r\n        g: () => {\r\n            return getLength(_running) + getLength(_waiting) === 0;\r\n        }\r\n    });\r\n\r\n    _addDebugState(theScheduler, () => _schedulerName,\r\n        () => {\r\n            return {\r\n                l: _theTask,\r\n                r: _running,\r\n                w: _waiting\r\n            }\r\n        });\r\n\r\n    return theScheduler;\r\n}\r\n","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\n\r\nimport { getKnownSymbol, objDefineProp, WellKnownSymbols } from \"@nevware21/ts-utils\";\r\nimport { createAsyncAllPromise, createAsyncAllSettledPromise, createAsyncAnyPromise, createAsyncPromise, createAsyncRacePromise, createAsyncRejectedPromise, createAsyncResolvedPromise } from \"../promise/asyncPromise\";\r\nimport { IPromise } from \"../interfaces/IPromise\";\r\nimport { PromiseExecutor } from \"../interfaces/types\";\r\nimport { IPromiseResult } from \"../interfaces/IPromiseResult\";\r\n\r\nconst toStringTagSymbol: symbol = getKnownSymbol(WellKnownSymbols.toStringTag) as typeof Symbol.toStringTag;\r\n\r\n/**\r\n * The PolyPromiseConstructor interface represents the constructor for the polyfill Promise object.\r\n * @since 0.5.0\r\n * @group Polyfill\r\n */\r\nexport interface PolyPromiseConstructor {\r\n    /**\r\n     * Creates a new Promise.\r\n     * @constructor\r\n     * @param executor - A callback used to initialize the promise. This callback is passed two arguments:\r\n     * a resolve callback used to resolve the promise with a value or the result of another promise,\r\n     * and a reject callback used to reject the promise with a provided reason or error.\r\n     */\r\n    new <T>(executor: PromiseExecutor<T>): IPromise<T>;\r\n\r\n    /**\r\n     * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n     * This returned promise will resolve and execute it's pending chained operations __asynchronously__ using the optional\r\n     * provided timeout value to schedule when the chained items will be executed, or if the input contains no promises.\r\n     * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n     * and will reject with this first rejection message / error.\r\n     * When resolved or rejected any additional chained operations will execute __asynchronously__ using the optional\r\n     * timeout value to schedul when the chained item will be executed (eg. `then()`; `catch()`; `finally()`).\r\n     * @group Polyfill\r\n     * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n     * @returns\r\n     * <ul>\r\n     * <li> An already resolved `Promise`, if the input passed is empty.\r\n     * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n     * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n     * promises reject.\r\n     * </ul>\r\n     */\r\n    all<T>(input: Iterable<PromiseLike<T>>, timeout?: number): IPromise<T[]>;\r\n\r\n    /**\r\n     * The `createAsyncRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n     * settles with the eventual state of the first promise that settles.\r\n     * @description The `createAsyncRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n     * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n     * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n     * the first of these values found in the iterable.\r\n     * @since 0.5.0\r\n     * @group Polyfill\r\n     * @param values - An iterable object of promises.\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n     * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n     * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n     * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise is still\r\n     * asynchronously settled.\r\n     */\r\n    race<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n\r\n    /**\r\n     * The `createAsyncRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n     * settles with the eventual state of the first promise that settles.\r\n     * @description The `createAsyncRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n     * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n     * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n     * the first of these values found in the iterable.\r\n     * @since 0.5.0\r\n     * @group Polyfill\r\n     * @param values - An iterable object of promises.\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n     * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n     * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n     * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise is still\r\n     * asynchronously settled.\r\n     */\r\n    race<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>>;\r\n\r\n    /**\r\n     * The `createAsyncAnyPromise` method takes an iterable of promises as input and returns a single Promise.\r\n     * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n     * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n     * AggregateError containing an array of rejection reasons.\r\n     * @since 0.5.0\r\n     * @group Polyfill\r\n     * @param values - An iterable object of promises.\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n     * @returns A new Promise that is:\r\n     * - Already rejected, if the iterable passed is empty.\r\n     * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n     * is the fulfillment value of the first promise that was fulfilled.\r\n     * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n     * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n     * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n     * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n     * rejected.\r\n     */\r\n    any<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<Awaited<T>>;\r\n        \r\n    /**\r\n     * The `createAsyncAnyPromise` method takes an iterable of promises as input and returns a single Promise.\r\n     * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n     * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n     * AggregateError containing an array of rejection reasons.\r\n     * @since 0.5.0\r\n     * @group Polyfill\r\n     * @param values - An iterable object of promises.\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n     * @returns A new Promise that is:\r\n     * - Already rejected, if the iterable passed is empty.\r\n     * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n     * is the fulfillment value of the first promise that was fulfilled.\r\n     * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n     * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n     * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n     * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n     * rejected.\r\n     */\r\n    any<T extends readonly unknown[] | []>(values: T, timeout?: number): IPromise<Awaited<T[number]>>;\r\n\r\n    /**\r\n     * Returns a single asynchronous Promise instance that is already rejected with the given reason.\r\n     * Any chained operations will execute __asynchronously__ using the optional timeout value to schedule\r\n     * when then chained items will be executed. (eg. `catch()`; `finally()`).\r\n     * @group Polyfill\r\n     * @param reason - The rejection reason\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n     * @returns A rejected promise.\r\n     */\r\n    reject<T = never>(reason?: any, timeout?: number): IPromise<T>;\r\n \r\n    /**\r\n     * Returns a single asynchronous Promise instance that is already resolved with the given value. If the value passed is\r\n     * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n     * If a new instance is returned then any chained operations will execute __asynchronously__ using the optional\r\n     * timeout value to schedule when the chained items will be executed.(eg. `then()`; `finally()`).\r\n     * @group Polyfill\r\n     * @returns A resolved promise.\r\n     */\r\n    resolve(): IPromise<void>;\r\n \r\n    /**\r\n     * Returns a single asynchronous Promise instance that is already resolved with the given value. If the value passed is\r\n     * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n     * If a new instance is returned then any chained operations will execute __asynchronously__ using the optional\r\n     * timeout value to schedule when the chained items will be executed.(eg. `then()`; `finally()`).\r\n     * @group Polyfill\r\n     * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n     * @returns A resolved promise.\r\n     */\r\n    resolve<T>(value: T | PromiseLike<T>, timeout?: number): IPromise<T>;\r\n\r\n    /**\r\n     * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n     * This returned promise will resolve and execute it's pending chained operations based on the\r\n     * {@link createAsyncPromise | Asynchronous} promise implementation. Any chained operations will execute\r\n     * __asynchronously__  when the final operation pending promises have resolved, or if the input contains\r\n     * no promises. It will resolve only after all of the input promises have either resolved or rejected,\r\n     * and will resolve with an array of {@link IPromiseResult } objects that each describe the outcome of\r\n     * each promise.\r\n     * @since 0.5.0\r\n     * @group Polyfill\r\n     * @param values - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n     * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n     */\r\n    allSettled<T extends readonly unknown[] | []>(values: T, timeout?: number): Promise<{ -readonly [P in keyof T]: IPromiseResult<Awaited<T[P]>>; }>;\r\n\r\n    /**\r\n     * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n     * This returned promise will resolve and execute it's pending chained operations based on the\r\n     * {@link createAsyncPromise | Asynchronous} promise implementation. Any chained operations will execute\r\n     * __asynchronously__  when the final operation pending promises have resolved, or if the input contains\r\n     * no promises. It will resolve only after all of the input promises have either resolved or rejected,\r\n     * and will resolve with an array of {@link IPromiseResult } objects that each describe the outcome of\r\n     * each promise.\r\n     * @since 0.5.0\r\n     * @group Polyfill\r\n     * @param values - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n     * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n     * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n     */\r\n    allSettled<T>(values: Iterable<T | PromiseLike<T>>, timeout?: number): IPromise<IPromiseResult<Awaited<T>>[]>;\r\n}\r\n\r\n/**\r\n * A full polyfill for the Promise class.\r\n * Represents the completion of an asynchronous operation, and its resulting value.\r\n * @since 0.5.0\r\n * @class\r\n * @group Polyfill\r\n * @group Promise\r\n */\r\nexport let PolyPromise = /*#__PURE__*/(function () {\r\n    /**\r\n     * Creates a new Promise.\r\n     * @constructor\r\n     * @param executor - A callback used to initialize the promise. This callback is passed two arguments:\r\n     * a resolve callback used to resolve the promise with a value or the result of another promise,\r\n     * and a reject callback used to reject the promise with a provided reason or error.\r\n     */\r\n    function PolyPromiseImpl<T>(executor: PromiseExecutor<T>) {\r\n        this._$ = createAsyncPromise(executor);\r\n        if (toStringTagSymbol) {\r\n            this[toStringTagSymbol] = \"Promise\";\r\n        }\r\n        // Re-Expose the state of the underlying promise\r\n        objDefineProp(this, \"state\", {\r\n            get: function() {\r\n                return this._$.state;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     */\r\n    PolyPromiseImpl.all = createAsyncAllPromise;\r\n    PolyPromiseImpl.race = createAsyncRacePromise;\r\n    PolyPromiseImpl.any = createAsyncAnyPromise;\r\n    PolyPromiseImpl.reject = createAsyncRejectedPromise;\r\n    PolyPromiseImpl.resolve = createAsyncResolvedPromise;\r\n    PolyPromiseImpl.allSettled = createAsyncAllSettledPromise;\r\n    let theProto = PolyPromiseImpl.prototype;\r\n    theProto.then = function (onResolved: any, onRejected: any) {\r\n        return this._$.then(onResolved, onRejected);\r\n    };\r\n    theProto.catch = function (onRejected: any) {\r\n        return this._$.catch(onRejected);\r\n    };\r\n    theProto.finally = function (onfinally: any) {\r\n        return this._$.finally(onfinally);\r\n    };\r\n    return PolyPromiseImpl as unknown as PolyPromiseConstructor;\r\n}());"],"names":["isPromiseLike","_addDebugState","objDefineProperties","getDocument","createCachedValue","safe","getInst","dumpObj","isFunction","createCustomError","arrSlice","isUndefined","scheduleTimeout","isNode","getWindow","getGlobal","objDefine","objDefineProp","objToString","hasSymbol","getKnownSymbol","throwTypeError","iterForOf","isArray","arrForEach","isIterable","isNumber","scheduleIdleCallback","utcNow","getLength","isIterator","fnCall","arrIndexOf"],"mappings":"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"}